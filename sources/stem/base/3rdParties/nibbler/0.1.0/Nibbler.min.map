{"version":3,"file":"Nibbler.min.js","sources":["Nibbler.js"],"names":["Nibbler","options","construct","pad","dataBits","codeBits","keyString","arrayData","mask","group","max","gcd","translate","encode","decode","i","mag","prev","Math","push","a","b","t","input","bitsIn","bitsOut","decoding","len","chr","byteIn","buffer","size","output","write","n","String","fromCharCode","charAt","length","indexOf","charCodeAt","join","this"],"mappings":"AA6DAA,QAAU,SAAUC,GACnB,YAQA,IAAIC,GAGHC,EAAKC,EAAUC,EAAUC,EAAWC,EAGpCC,EAAMC,EAAOC,EAGbC,EAAKC,EAGLC,EAAQC,CAGTZ,GAAY,WACX,GAAIa,GAAGC,EAAKC,CAaZ,KAVAd,EAAMF,EAAQE,KAAO,GACrBC,EAAWH,EAAQG,SACnBC,EAAWJ,EAAQI,SACnBC,EAAYL,EAAQK,UACpBC,EAAYN,EAAQM,UAGpBS,EAAME,KAAKR,IAAIN,EAAUC,GACzBY,EAAO,EACPT,KACKO,EAAI,EAAOC,EAAJD,EAASA,GAAK,EACzBP,EAAKW,KAAKF,GACVA,GAAQA,EAAO,CAEhBP,GAAMO,EAGNR,EAAQL,EAAWO,EAAIP,EAAUC,IAIlCM,EAAM,SAAUS,EAAGC,GAElB,IADA,GAAIC,GACS,IAAND,GACNC,EAAID,EACJA,EAAID,EAAIC,EACRD,EAAIE,CAEL,OAAOF,IAIRR,EAAY,SAAUW,EAAOC,EAAQC,EAASC,GAC7C,GAAIX,GAAGY,EAAKC,EAAKC,EAChBC,EAAQC,EAAMC,EACdC,CAkBD,KAfAA,EAAQ,SAAUC,GAIhBF,EAAOb,KAHHO,EAEMnB,EACE2B,EAEAC,OAAOC,aAAaF,GAJpB5B,EAAU+B,OAAOH,KAQ/BJ,EAAS,EACTC,EAAO,EACPC,KAEAL,EAAMJ,EAAMe,OACPvB,EAAI,EAAOY,EAAJZ,EAASA,GAAK,EAAG,CAK5B,GAHAgB,GAAQP,EAGJE,EAAU,CAIb,GAFAE,EAAML,EAAMc,OAAOtB,GACnBc,EAASvB,EAAUiC,QAAQX,GACvBA,IAAQzB,EACX,KACM,IAAa,EAAT0B,EACV,KAAM,kBAAoBD,EAAM,wBAA0BtB,MAQ3D,IAJCuB,EADGtB,EACMgB,EAAMR,GAENQ,EAAMiB,WAAWzB,IAEtBc,EAASnB,KAASA,EACtB,KAAMmB,GAAS,2BAA6BnB,CAQ9C,KAHAoB,EAAUA,GAAUN,EAAUK,EAGvBE,GAAQN,GAEdM,GAAQN,EAIRQ,EAAMH,GAAUC,GAIhBD,GAAUtB,EAAKuB,GAMjB,IAAKL,GAAYK,EAAO,EAMvB,IAHAE,EAAMH,GAAWL,EAAUM,GAGpBC,EAAOM,OAAS7B,EAAQ,GAC9BuB,EAAOb,KAAKhB,EAKd,OAAQI,IAAamB,EAAYM,EAASA,EAAOS,KAAK,KAMvD5B,EAAS,SAAUU,GAClB,MAAOX,GAAUW,EAAOnB,EAAUC,GAAU,IAM7CS,EAAS,SAAUS,GAClB,MAAOX,GAAUW,EAAOlB,EAAUD,GAAU,IAG7CsC,KAAK7B,OAASA,EACd6B,KAAK5B,OAASA,EACdZ","sourcesContent":["/*\r\nCopyright (c) 2010-2013 Thomas Peri\r\nhttp://www.tumuski.com/\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a\r\ncopy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true,\r\n\teqeqeq: true, plusplus: true, regexp: true, newcap: true, immed: true */\r\n// (good parts minus bitwise and strict, plus white.)\r\n\r\n/**\r\n * Nibbler - Multi-Base Encoder\r\n *\r\n * version 2013-04-24\r\n *\r\n * Options:\r\n *   dataBits: The number of bits in each character of unencoded data.\r\n *   codeBits: The number of bits in each character of encoded data.\r\n *   keyString: The characters that correspond to each value when encoded.\r\n *   pad (optional): The character to pad the end of encoded output.\r\n *   arrayData (optional): If truthy, unencoded data is an array instead of a string.\r\n *\r\n * Example: \r\n *\r\n * var base64_8bit = new Nibbler({\r\n *     dataBits: 8,\r\n *     codeBits: 6,\r\n *     keyString: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\r\n *     pad: '='\r\n * });\r\n * base64_8bit.encode(\"Hello, World!\");  // returns \"SGVsbG8sIFdvcmxkIQ==\"\r\n * base64_8bit.decode(\"SGVsbG8sIFdvcmxkIQ==\");  // returns \"Hello, World!\"\r\n *\r\n * var base64_7bit = new Nibbler({\r\n *     dataBits: 7,\r\n *     codeBits: 6,\r\n *     keyString: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\r\n *     pad: '='\r\n * });\r\n * base64_7bit.encode(\"Hello, World!\");  // returns \"kZdmzesQV9/LZkQg==\"\r\n * base64_7bit.decode(\"kZdmzesQV9/LZkQg==\");  // returns \"Hello, World!\"\r\n *\r\n */\r\nNibbler = function (options) {\r\n\t\"use strict\";\r\n\t\r\n\t// Code quality tools like jshint warn about bitwise operators,\r\n\t// because they're easily confused with other more common operators,\r\n\t// and because they're often misused for doing arithmetic.  Nibbler uses\r\n\t// them properly, though, for moving individual bits, so turn off the warning.\r\n\t/*jshint bitwise:false */\r\n\t\r\n\tvar construct,\r\n\t\t\r\n\t\t// options\r\n\t\tpad, dataBits, codeBits, keyString, arrayData,\r\n\t\t\r\n\t\t// private instance variables\r\n\t\tmask, group, max,\r\n\t\t\r\n\t\t// private methods\r\n\t\tgcd, translate,\r\n\t\t\r\n\t\t// public methods\r\n\t\tencode, decode;\r\n\t\r\n\t// pseudo-constructor\r\n\tconstruct = function () {\r\n\t\tvar i, mag, prev;\r\n\r\n\t\t// options\r\n\t\tpad = options.pad || '';\r\n\t\tdataBits = options.dataBits;\r\n\t\tcodeBits = options.codeBits;\r\n\t\tkeyString = options.keyString;\r\n\t\tarrayData = options.arrayData;\r\n\t\t\r\n\t\t// bitmasks\r\n\t\tmag = Math.max(dataBits, codeBits);\r\n\t\tprev = 0;\r\n\t\tmask = [];\r\n\t\tfor (i = 0; i < mag; i += 1) {\r\n\t\t\tmask.push(prev);\r\n\t\t\tprev += prev + 1;\r\n\t\t}\r\n\t\tmax = prev;\r\n\t\t\r\n\t\t// ouput code characters in multiples of this number\r\n\t\tgroup = dataBits / gcd(dataBits, codeBits);\r\n\t};\r\n\r\n\t// greatest common divisor\r\n\tgcd = function (a, b) {\r\n\t\tvar t;\r\n\t\twhile (b !== 0) {\r\n\t\t\tt = b;\r\n\t\t\tb = a % b;\r\n\t\t\ta = t;\r\n\t\t}\r\n\t\treturn a;\r\n\t};\r\n\r\n\t// the re-coder\r\n\ttranslate = function (input, bitsIn, bitsOut, decoding) {\r\n\t\tvar i, len, chr, byteIn,\r\n\t\t\tbuffer, size, output,\r\n\t\t\twrite;\r\n\t\t\r\n\t\t// append a byte to the output\r\n\t\twrite = function (n) {\r\n\t\t\tif (!decoding) {\r\n\t\t\t\toutput.push(keyString.charAt(n));\r\n\t\t\t} else if (arrayData) {\r\n\t\t\t\toutput.push(n);\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(String.fromCharCode(n));\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tbuffer = 0;\r\n\t\tsize = 0;\r\n\t\toutput = [];\r\n\t\t\r\n\t\tlen = input.length;\r\n\t\tfor (i = 0; i < len; i += 1) {\r\n\t\t\t// the new size the buffer will be after adding these bits\r\n\t\t\tsize += bitsIn;\r\n\t\t\t\r\n\t\t\t// read a character\r\n\t\t\tif (decoding) {\r\n\t\t\t\t// decode it\r\n\t\t\t\tchr = input.charAt(i);\r\n\t\t\t\tbyteIn = keyString.indexOf(chr);\r\n\t\t\t\tif (chr === pad) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byteIn < 0) {\r\n\t\t\t\t\tthrow 'the character \"' + chr + '\" is not a member of ' + keyString;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (arrayData) {\r\n\t\t\t\t\tbyteIn = input[i];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbyteIn = input.charCodeAt(i);\r\n\t\t\t\t}\r\n\t\t\t\tif ((byteIn | max) !== max) {\r\n\t\t\t\t\tthrow byteIn + \" is outside the range 0-\" + max;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// shift the buffer to the left and add the new bits\r\n\t\t\tbuffer = (buffer << bitsIn) | byteIn;\r\n\t\t\t\r\n\t\t\t// as long as there's enough in the buffer for another output...\r\n\t\t\twhile (size >= bitsOut) {\r\n\t\t\t\t// the new size the buffer will be after an output\r\n\t\t\t\tsize -= bitsOut;\r\n\t\t\t\t\r\n\t\t\t\t// output the part that lies to the left of that number of bits\r\n\t\t\t\t// by shifting the them to the right\r\n\t\t\t\twrite(buffer >> size);\r\n\t\t\t\t\r\n\t\t\t\t// remove the bits we wrote from the buffer\r\n\t\t\t\t// by applying a mask with the new size\r\n\t\t\t\tbuffer &= mask[size];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If we're encoding and there's input left over, pad the output.\r\n\t\t// Otherwise, leave the extra bits off, 'cause they themselves are padding\r\n\t\tif (!decoding && size > 0) {\r\n\t\t\r\n\t\t\t// flush the buffer\r\n\t\t\twrite(buffer << (bitsOut - size));\r\n\r\n\t\t\t// add padding string for the remainder of the group\r\n\t\t\twhile (output.length % group > 0) {\r\n\t\t\t\toutput.push(pad);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// string!\r\n\t\treturn (arrayData && decoding) ? output : output.join('');\r\n\t};\r\n\t\r\n\t/**\r\n\t * Encode.  Input and output are strings.\r\n\t */\r\n\tencode = function (input) {\r\n\t\treturn translate(input, dataBits, codeBits, false);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Decode.  Input and output are strings.\r\n\t */\r\n\tdecode = function (input) {\r\n\t\treturn translate(input, codeBits, dataBits, true);\r\n\t};\r\n\t\r\n\tthis.encode = encode;\r\n\tthis.decode = decode;\r\n\tconstruct();\r\n};"]}