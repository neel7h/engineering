{"version":3,"file":"highcharts-more.min.js","sources":["highcharts-more.js"],"names":["Highcharts","UNDEFINED","Pane","options","chart","firstAxis","this","init","call","initArea","proceed","polar","closeSegment","path","center","xAxis","push","closedStacks","polarAnimate","attribs","animation","group","markerGroup","plotLeft","plotTop","renderer","isSVG","translateX","translateY","scaleX","scaleY","attr","attrSetters","animate","arrayMin","arrayMax","each","extend","merge","map","pick","pInt","defaultPlotOptions","getOptions","plotOptions","seriesTypes","extendClass","splat","wrap","Axis","Tick","Series","colProto","column","prototype","math","Math","mathRound","round","mathFloor","floor","mathMax","max","noop","backgroundOption","pane","defaultOptions","angular","background","concat","reverse","config","backgroundColor","defaultBackgroundOptions","color","plotBands","unshift","size","startAngle","shape","borderWidth","borderColor","linearGradient","x1","y1","x2","y2","stops","from","Number","MIN_VALUE","innerRadius","to","MAX_VALUE","outerRadius","axisProto","tickProto","hiddenAxisMixin","getOffset","redraw","isDirty","render","setScale","setCategories","setTitle","radialAxisMixin","isRadial","defaultRadialGaugeOptions","labels","align","x","y","minorGridLineWidth","minorTickInterval","minorTickLength","minorTickPosition","minorTickWidth","tickLength","tickPosition","tickWidth","title","rotation","zIndex","defaultRadialXOptions","gridLineWidth","distance","maxPadding","minPadding","showLastLabel","defaultRadialYOptions","gridLineInterpolation","text","setOptions","userOptions","defaultRadialOptions","axisOffset","side","pie","getCenter","getLinePath","lineWidth","radius","offset","symbols","arc","left","top","start","startAngleRad","end","endAngleRad","open","innerR","setAxisTranslation","transA","isCircular","min","isXAxis","minPixelPadding","minPointOffset","reversed","beforeSetTickPositions","autoConnect","categories","pointRange","closestPointRange","setAxisSize","len","width","height","getPosition","value","length","translate","postTranslate","angle","cos","sin","getPlotBandPath","ret","fullRadius","radii","thickness","percentRegex","getPlotLinePath","test","PI","xy","tickPositions","axis","pos","i","getTitlePosition","titleOptions","high","middle","low","paneOptions","isX","isHidden","chartOptions","paneIndex","defaultYAxisOptions","panes","inverted","zoomType","endAngle","horiz","tickmarkOffset","old","label","labelOptions","index","step","optionsY","styles","lineHeight","getBBox","endPoint","arearange","area","marker","threshold","tooltip","pointFormat","trackByArea","dataLabels","verticalAlign","xLow","xHigh","yLow","yHigh","type","pointArrayMap","toYData","point","pointValKey","getSegments","series","points","connectNulls","yAxis","apply","plotY","plotLow","plotHigh","getSegmentPath","segment","lowSegment","linePath","lowerPath","higherPath","highSegment","baseGetSegmentPath","HighchartsAdapter","grep","plotX","right","areaPath","drawDataLabels","data","originalDataLabels","seriesProto","dataLabelOptions","enabled","_hasPointLabels","dataLabel","dataLabelUpper","below","arguments","alignDataLabel","getSymbol","drawPoints","areasplinerange","getPointSpline","spline","columnrange","heightDifference","shapeArgs","minPointLength","trackerGroups","drawGraph","pointAttrToOptions","drawTracker","getColumnMetrics","gauge","line","borderRadius","style","fontWeight","dial","pivot","headerFormat","showInLegend","GaugePoint","Point","setState","state","GaugeSeries","pointClass","generatePoints","dialOptions","baseLength","rearLength","baseWidth","topWidth","shapeType","d","pivotOptions","graphic","stroke","stroke-width","fill","add","circle","plotGroup","visible","seriesGroup","clip","clipRect","setData","boxplot","fillColor","medianWidth","states","hover","brightness","whiskerLength","whiskerWidth","q1","median","q3","key","pointAttr","q1Plot","q3Plot","highPlot","lowPlot","medianPlot","crispCorr","crispX","stemPath","stemAttr","boxPath","whiskersPath","whiskersAttr","medianPath","medianAttr","halfWidth","doQuartiles","parseInt","selected","stemColor","stemWidth","dashstyle","stemDashStyle","whiskerColor","medianColor","stem","whiskers","box","medianShape","g","errorbar","grouping","linkedTo","linkedParent","columnMetrics","waterfall","lineColor","dashStyle","upColorProp","stacking","stack","previousY","stackPoint","getStack","isNaN","yData","isSum","isIntermediateSum","total","yBottom","processData","force","subSum","sum","dataMin","dataMax","dataLength","pt","getAttribs","stateOptions","upColor","hoverColor","Color","brighten","get","seriesDownPointAttr","select","getGraphPath","prevArgs","pointArgs","normalizer","M","L","getExtremes","stacks","stackKey","processedYData","bubble","scatter","inside","textShadow","minSize","maxSize","turboThreshold","zThreshold","applyOpacity","markerOptions","fillOpacity","setOpacity","convertAttribs","obj","getRadii","zMin","zMax","zRange","zData","ceil","r","negative","z","minPxSize","dlBox","drawLegendSymbol","legend","item","itemStyle","fontSize","legendSymbol","baseline","legendGroup","isMarker","beforePadding","axisLength","pxMin","pxMax","dataKey","extremes","smallestSize","plotWidth","plotHeight","range","activeSeries","seriesOptions","allowZoomOutside","prop","isPercent","displayNegative","userMin","userMax","pointerProto","Pointer","toXY","rectPlotX","rectPlotY","clientX","polarPlotX","polarPlotY","orderTooltipPoints","sort","a","b","wrappedClientX","areaspline","lastPoint","nextPoint","lastX","lastY","nextX","nextY","leftContX","leftContY","rightContX","rightContY","distanceLeftControlPoint","distanceRightControlPoint","leftContAngle","rightContAngle","jointAngle","smoothing","denom","connectEnds","sqrt","pow","atan2","abs","preventPostTranslate","renew","tooltipLen","barX","pointWidth","alignTo","isNew","e","chartX","chartY","axes"],"mappings":"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","sourcesContent":["// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v3.0.5 (2013-08-23)\n *\n * (c) 2009-2013 Torstein HÃ¸nsi\n *\n * License: www.highcharts.com/license\n */\n\n// JSLint options:\n/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console */\n\n(function (Highcharts, UNDEFINED) {\nvar arrayMin = Highcharts.arrayMin,\n\tarrayMax = Highcharts.arrayMax,\n\teach = Highcharts.each,\n\textend = Highcharts.extend,\n\tmerge = Highcharts.merge,\n\tmap = Highcharts.map,\n\tpick = Highcharts.pick,\n\tpInt = Highcharts.pInt,\n\tdefaultPlotOptions = Highcharts.getOptions().plotOptions,\n\tseriesTypes = Highcharts.seriesTypes,\n\textendClass = Highcharts.extendClass,\n\tsplat = Highcharts.splat,\n\twrap = Highcharts.wrap,\n\tAxis = Highcharts.Axis,\n\tTick = Highcharts.Tick,\n\tSeries = Highcharts.Series,\n\tcolProto = seriesTypes.column.prototype,\n\tmath = Math,\n\tmathRound = math.round,\n\tmathFloor = math.floor,\n\tmathMax = math.max,\n\tnoop = function () {};/**\n * The Pane object allows options that are common to a set of X and Y axes.\n * \n * In the future, this can be extended to basic Highcharts and Highstock.\n */\nfunction Pane(options, chart, firstAxis) {\n\tthis.init.call(this, options, chart, firstAxis);\n}\n\n// Extend the Pane prototype\nextend(Pane.prototype, {\n\t\n\t/**\n\t * Initiate the Pane object\n\t */\n\tinit: function (options, chart, firstAxis) {\n\t\tvar pane = this,\n\t\t\tbackgroundOption,\n\t\t\tdefaultOptions = pane.defaultOptions;\n\t\t\n\t\tpane.chart = chart;\n\t\t\n\t\t// Set options\n\t\tif (chart.angular) { // gauges\n\t\t\tdefaultOptions.background = {}; // gets extended by this.defaultBackgroundOptions\n\t\t}\n\t\tpane.options = options = merge(defaultOptions, options);\n\t\t\n\t\tbackgroundOption = options.background;\n\t\t\n\t\t// To avoid having weighty logic to place, update and remove the backgrounds,\n\t\t// push them to the first axis' plot bands and borrow the existing logic there.\n\t\tif (backgroundOption) {\n\t\t\teach([].concat(splat(backgroundOption)).reverse(), function (config) {\n\t\t\t\tvar backgroundColor = config.backgroundColor; // if defined, replace the old one (specific for gradients)\n\t\t\t\tconfig = merge(pane.defaultBackgroundOptions, config);\n\t\t\t\tif (backgroundColor) {\n\t\t\t\t\tconfig.backgroundColor = backgroundColor;\n\t\t\t\t}\n\t\t\t\tconfig.color = config.backgroundColor; // due to naming in plotBands\n\t\t\t\tfirstAxis.options.plotBands.unshift(config);\n\t\t\t});\n\t\t}\n\t},\n\t\n\t/**\n\t * The default options object\n\t */\n\tdefaultOptions: {\n\t\t// background: {conditional},\n\t\tcenter: ['50%', '50%'],\n\t\tsize: '85%',\n\t\tstartAngle: 0\n\t\t//endAngle: startAngle + 360\n\t},\t\n\t\n\t/**\n\t * The default background options\n\t */\n\tdefaultBackgroundOptions: {\n\t\tshape: 'circle',\n\t\tborderWidth: 1,\n\t\tborderColor: 'silver',\n\t\tbackgroundColor: {\n\t\t\tlinearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n\t\t\tstops: [\n\t\t\t\t[0, '#FFF'],\n\t\t\t\t[1, '#DDD']\n\t\t\t]\n\t\t},\n\t\tfrom: Number.MIN_VALUE, // corrected to axis min\n\t\tinnerRadius: 0,\n\t\tto: Number.MAX_VALUE, // corrected to axis max\n\t\touterRadius: '105%'\n\t}\n\t\n});\nvar axisProto = Axis.prototype,\n\ttickProto = Tick.prototype;\n\t\n/**\n * Augmented methods for the x axis in order to hide it completely, used for the X axis in gauges\n */\nvar hiddenAxisMixin = {\n\tgetOffset: noop,\n\tredraw: function () {\n\t\tthis.isDirty = false; // prevent setting Y axis dirty\n\t},\n\trender: function () {\n\t\tthis.isDirty = false; // prevent setting Y axis dirty\n\t},\n\tsetScale: noop,\n\tsetCategories: noop,\n\tsetTitle: noop\n};\n\n/**\n * Augmented methods for the value axis\n */\n/*jslint unparam: true*/\nvar radialAxisMixin = {\n\tisRadial: true,\n\t\n\t/**\n\t * The default options extend defaultYAxisOptions\n\t */\n\tdefaultRadialGaugeOptions: {\n\t\tlabels: {\n\t\t\talign: 'center',\n\t\t\tx: 0,\n\t\t\ty: null // auto\n\t\t},\n\t\tminorGridLineWidth: 0,\n\t\tminorTickInterval: 'auto',\n\t\tminorTickLength: 10,\n\t\tminorTickPosition: 'inside',\n\t\tminorTickWidth: 1,\n\t\tplotBands: [],\n\t\ttickLength: 10,\n\t\ttickPosition: 'inside',\n\t\ttickWidth: 2,\n\t\ttitle: {\n\t\t\trotation: 0\n\t\t},\n\t\tzIndex: 2 // behind dials, points in the series group\n\t},\n\t\n\t// Circular axis around the perimeter of a polar chart\n\tdefaultRadialXOptions: {\n\t\tgridLineWidth: 1, // spokes\n\t\tlabels: {\n\t\t\talign: null, // auto\n\t\t\tdistance: 15,\n\t\t\tx: 0,\n\t\t\ty: null // auto\n\t\t},\n\t\tmaxPadding: 0,\n\t\tminPadding: 0,\n\t\tplotBands: [],\n\t\tshowLastLabel: false, \n\t\ttickLength: 0\n\t},\n\t\n\t// Radial axis, like a spoke in a polar chart\n\tdefaultRadialYOptions: {\n\t\tgridLineInterpolation: 'circle',\n\t\tlabels: {\n\t\t\talign: 'right',\n\t\t\tx: -3,\n\t\t\ty: -2\n\t\t},\n\t\tplotBands: [],\n\t\tshowLastLabel: false,\n\t\ttitle: {\n\t\t\tx: 4,\n\t\t\ttext: null,\n\t\t\trotation: 90\n\t\t}\n\t},\n\t\n\t/**\n\t * Merge and set options\n\t */\n\tsetOptions: function (userOptions) {\n\t\t\n\t\tthis.options = merge(\n\t\t\tthis.defaultOptions,\n\t\t\tthis.defaultRadialOptions,\n\t\t\tuserOptions\n\t\t);\n\t\t\n\t},\n\t\n\t/**\n\t * Wrap the getOffset method to return zero offset for title or labels in a radial \n\t * axis\n\t */\n\tgetOffset: function () {\n\t\t// Call the Axis prototype method (the method we're in now is on the instance)\n\t\taxisProto.getOffset.call(this);\n\t\t\n\t\t// Title or label offsets are not counted\n\t\tthis.chart.axisOffset[this.side] = 0;\n\t\t\n\t\t// Set the center array\n\t\tthis.center = this.pane.center = seriesTypes.pie.prototype.getCenter.call(this.pane);\n\t},\n\n\n\t/**\n\t * Get the path for the axis line. This method is also referenced in the getPlotLinePath\n\t * method.\n\t */\n\tgetLinePath: function (lineWidth, radius) {\n\t\tvar center = this.center;\n\t\tradius = pick(radius, center[2] / 2 - this.offset);\n\t\t\n\t\treturn this.chart.renderer.symbols.arc(\n\t\t\tthis.left + center[0],\n\t\t\tthis.top + center[1],\n\t\t\tradius,\n\t\t\tradius, \n\t\t\t{\n\t\t\t\tstart: this.startAngleRad,\n\t\t\t\tend: this.endAngleRad,\n\t\t\t\topen: true,\n\t\t\t\tinnerR: 0\n\t\t\t}\n\t\t);\n\t},\n\n\t/**\n\t * Override setAxisTranslation by setting the translation to the difference\n\t * in rotation. This allows the translate method to return angle for \n\t * any given value.\n\t */\n\tsetAxisTranslation: function () {\n\t\t\n\t\t// Call uber method\t\t\n\t\taxisProto.setAxisTranslation.call(this);\n\t\t\t\n\t\t// Set transA and minPixelPadding\n\t\tif (this.center) { // it's not defined the first time\n\t\t\tif (this.isCircular) {\n\t\t\t\t\n\t\t\t\tthis.transA = (this.endAngleRad - this.startAngleRad) / \n\t\t\t\t\t((this.max - this.min) || 1);\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t} else { \n\t\t\t\tthis.transA = (this.center[2] / 2) / ((this.max - this.min) || 1);\n\t\t\t}\n\t\t\t\n\t\t\tif (this.isXAxis) {\n\t\t\t\tthis.minPixelPadding = this.transA * this.minPointOffset +\n\t\t\t\t\t(this.reversed ? (this.endAngleRad - this.startAngleRad) / 4 : 0); // ???\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * In case of auto connect, add one closestPointRange to the max value right before\n\t * tickPositions are computed, so that ticks will extend passed the real max.\n\t */\n\tbeforeSetTickPositions: function () {\n\t\tif (this.autoConnect) {\n\t\t\tthis.max += (this.categories && 1) || this.pointRange || this.closestPointRange; // #1197\n\t\t}\n\t},\n\t\n\t/**\n\t * Override the setAxisSize method to use the arc's circumference as length. This\n\t * allows tickPixelInterval to apply to pixel lengths along the perimeter\n\t */\n\tsetAxisSize: function () {\n\t\t\n\t\taxisProto.setAxisSize.call(this);\n\t\t\n\t\tif (this.center) { // it's not defined the first time\n\t\t\tthis.len = this.width = this.height = this.isCircular ?\n\t\t\t\tthis.center[2] * (this.endAngleRad - this.startAngleRad) / 2 :\n\t\t\t\tthis.center[2] / 2;\n\t\t}\n\t},\n\t\n\t/**\n\t * Returns the x, y coordinate of a point given by a value and a pixel distance\n\t * from center\n\t */\n\tgetPosition: function (value, length) {\n\t\tif (!this.isCircular) {\n\t\t\tlength = this.translate(value);\n\t\t\tvalue = this.min;\t\n\t\t}\n\t\t\n\t\treturn this.postTranslate(\n\t\t\tthis.translate(value),\n\t\t\tpick(length, this.center[2] / 2) - this.offset\n\t\t);\t\t\n\t},\n\t\n\t/**\n\t * Translate from intermediate plotX (angle), plotY (axis.len - radius) to final chart coordinates. \n\t */\n\tpostTranslate: function (angle, radius) {\n\t\t\n\t\tvar chart = this.chart,\n\t\t\tcenter = this.center;\n\t\t\t\n\t\tangle = this.startAngleRad + angle;\n\t\t\n\t\treturn {\n\t\t\tx: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n\t\t\ty: chart.plotTop + center[1] + Math.sin(angle) * radius\n\t\t}; \n\t\t\n\t},\n\t\n\t/**\n\t * Find the path for plot bands along the radial axis\n\t */\n\tgetPlotBandPath: function (from, to, options) {\n\t\tvar center = this.center,\n\t\t\tstartAngleRad = this.startAngleRad,\n\t\t\tfullRadius = center[2] / 2,\n\t\t\tradii = [\n\t\t\t\tpick(options.outerRadius, '100%'),\n\t\t\t\toptions.innerRadius,\n\t\t\t\tpick(options.thickness, 10)\n\t\t\t],\n\t\t\tpercentRegex = /%$/,\n\t\t\tstart,\n\t\t\tend,\n\t\t\topen,\n\t\t\tisCircular = this.isCircular, // X axis in a polar chart\n\t\t\tret;\n\t\t\t\n\t\t// Polygonal plot bands\n\t\tif (this.options.gridLineInterpolation === 'polygon') {\n\t\t\tret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true));\n\t\t\n\t\t// Circular grid bands\n\t\t} else {\n\t\t\t\n\t\t\t// Plot bands on Y axis (radial axis) - inner and outer radius depend on to and from\n\t\t\tif (!isCircular) {\n\t\t\t\tradii[0] = this.translate(from);\n\t\t\t\tradii[1] = this.translate(to);\n\t\t\t}\n\t\t\t\n\t\t\t// Convert percentages to pixel values\n\t\t\tradii = map(radii, function (radius) {\n\t\t\t\tif (percentRegex.test(radius)) {\n\t\t\t\t\tradius = (pInt(radius, 10) * fullRadius) / 100;\n\t\t\t\t}\n\t\t\t\treturn radius;\n\t\t\t});\n\t\t\t\n\t\t\t// Handle full circle\n\t\t\tif (options.shape === 'circle' || !isCircular) {\n\t\t\t\tstart = -Math.PI / 2;\n\t\t\t\tend = Math.PI * 1.5;\n\t\t\t\topen = true;\n\t\t\t} else {\n\t\t\t\tstart = startAngleRad + this.translate(from);\n\t\t\t\tend = startAngleRad + this.translate(to);\n\t\t\t}\n\t\t\n\t\t\n\t\t\tret = this.chart.renderer.symbols.arc(\n\t\t\t\tthis.left + center[0],\n\t\t\t\tthis.top + center[1],\n\t\t\t\tradii[0],\n\t\t\t\tradii[0],\n\t\t\t\t{\n\t\t\t\t\tstart: start,\n\t\t\t\t\tend: end,\n\t\t\t\t\tinnerR: pick(radii[1], radii[0] - radii[2]),\n\t\t\t\t\topen: open\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\t \n\t\treturn ret;\n\t},\n\t\n\t/**\n\t * Find the path for plot lines perpendicular to the radial axis.\n\t */\n\tgetPlotLinePath: function (value, reverse) {\n\t\tvar axis = this,\n\t\t\tcenter = axis.center,\n\t\t\tchart = axis.chart,\n\t\t\tend = axis.getPosition(value),\n\t\t\txAxis,\n\t\t\txy,\n\t\t\ttickPositions,\n\t\t\tret;\n\t\t\n\t\t// Spokes\n\t\tif (axis.isCircular) {\n\t\t\tret = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];\n\t\t\n\t\t// Concentric circles\t\t\t\n\t\t} else if (axis.options.gridLineInterpolation === 'circle') {\n\t\t\tvalue = axis.translate(value);\n\t\t\tif (value) { // a value of 0 is in the center\n\t\t\t\tret = axis.getLinePath(0, value);\n\t\t\t}\n\t\t// Concentric polygons \n\t\t} else {\n\t\t\txAxis = chart.xAxis[0];\n\t\t\tret = [];\n\t\t\tvalue = axis.translate(value);\n\t\t\ttickPositions = xAxis.tickPositions;\n\t\t\tif (xAxis.autoConnect) {\n\t\t\t\ttickPositions = tickPositions.concat([tickPositions[0]]);\n\t\t\t}\n\t\t\t// Reverse the positions for concatenation of polygonal plot bands\n\t\t\tif (reverse) {\n\t\t\t\ttickPositions = [].concat(tickPositions).reverse();\n\t\t\t}\n\t\t\t\t\n\t\t\teach(tickPositions, function (pos, i) {\n\t\t\t\txy = xAxis.getPosition(pos, value);\n\t\t\t\tret.push(i ? 'L' : 'M', xy.x, xy.y);\n\t\t\t});\n\t\t\t\n\t\t}\n\t\treturn ret;\n\t},\n\t\n\t/**\n\t * Find the position for the axis title, by default inside the gauge\n\t */\n\tgetTitlePosition: function () {\n\t\tvar center = this.center,\n\t\t\tchart = this.chart,\n\t\t\ttitleOptions = this.options.title;\n\t\t\n\t\treturn { \n\t\t\tx: chart.plotLeft + center[0] + (titleOptions.x || 0), \n\t\t\ty: chart.plotTop + center[1] - ({ high: 0.5, middle: 0.25, low: 0 }[titleOptions.align] * \n\t\t\t\tcenter[2]) + (titleOptions.y || 0)  \n\t\t};\n\t}\n\t\n};\n/*jslint unparam: false*/\n\n/**\n * Override axisProto.init to mix in special axis instance functions and function overrides\n */\nwrap(axisProto, 'init', function (proceed, chart, userOptions) {\n\tvar axis = this,\n\t\tangular = chart.angular,\n\t\tpolar = chart.polar,\n\t\tisX = userOptions.isX,\n\t\tisHidden = angular && isX,\n\t\tisCircular,\n\t\tstartAngleRad,\n\t\tendAngleRad,\n\t\toptions,\n\t\tchartOptions = chart.options,\n\t\tpaneIndex = userOptions.pane || 0,\n\t\tpane,\n\t\tpaneOptions;\n\t\t\n\t// Before prototype.init\n\tif (angular) {\n\t\textend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);\n\t\tisCircular =  !isX;\n\t\tif (isCircular) {\n\t\t\tthis.defaultRadialOptions = this.defaultRadialGaugeOptions;\n\t\t}\n\t\t\n\t} else if (polar) {\n\t\t//extend(this, userOptions.isX ? radialAxisMixin : radialAxisMixin);\n\t\textend(this, radialAxisMixin);\n\t\tisCircular = isX;\n\t\tthis.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge(this.defaultYAxisOptions, this.defaultRadialYOptions);\n\t\t\n\t}\n\t\n\t// Run prototype.init\n\tproceed.call(this, chart, userOptions);\n\t\n\tif (!isHidden && (angular || polar)) {\n\t\toptions = this.options;\n\t\t\n\t\t// Create the pane and set the pane options.\n\t\tif (!chart.panes) {\n\t\t\tchart.panes = [];\n\t\t}\n\t\tthis.pane = pane = chart.panes[paneIndex] = chart.panes[paneIndex] || new Pane(\n\t\t\tsplat(chartOptions.pane)[paneIndex],\n\t\t\tchart,\n\t\t\taxis\n\t\t);\n\t\tpaneOptions = pane.options;\n\t\t\n\t\t\t\n\t\t// Disable certain features on angular and polar axes\n\t\tchart.inverted = false;\n\t\tchartOptions.chart.zoomType = null;\n\t\t\n\t\t// Start and end angle options are\n\t\t// given in degrees relative to top, while internal computations are\n\t\t// in radians relative to right (like SVG).\n\t\tthis.startAngleRad = startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;\n\t\tthis.endAngleRad = endAngleRad = (pick(paneOptions.endAngle, paneOptions.startAngle + 360)  - 90) * Math.PI / 180;\n\t\tthis.offset = options.offset || 0;\n\t\t\n\t\tthis.isCircular = isCircular;\n\t\t\n\t\t// Automatically connect grid lines?\n\t\tif (isCircular && userOptions.max === UNDEFINED && endAngleRad - startAngleRad === 2 * Math.PI) {\n\t\t\tthis.autoConnect = true;\n\t\t}\n\t}\n\t\n});\n\n/**\n * Add special cases within the Tick class' methods for radial axes.\n */\t\nwrap(tickProto, 'getPosition', function (proceed, horiz, pos, tickmarkOffset, old) {\n\tvar axis = this.axis;\n\t\n\treturn axis.getPosition ? \n\t\taxis.getPosition(pos) :\n\t\tproceed.call(this, horiz, pos, tickmarkOffset, old);\t\n});\n\n/**\n * Wrap the getLabelPosition function to find the center position of the label\n * based on the distance option\n */\t\nwrap(tickProto, 'getLabelPosition', function (proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n\tvar axis = this.axis,\n\t\toptionsY = labelOptions.y,\n\t\tret,\n\t\talign = labelOptions.align,\n\t\tangle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360;\n\t\n\tif (axis.isRadial) {\n\t\tret = axis.getPosition(this.pos, (axis.center[2] / 2) + pick(labelOptions.distance, -25));\n\t\t\n\t\t// Automatically rotated\n\t\tif (labelOptions.rotation === 'auto') {\n\t\t\tlabel.attr({ \n\t\t\t\trotation: angle\n\t\t\t});\n\t\t\n\t\t// Vertically centered\n\t\t} else if (optionsY === null) {\n\t\t\toptionsY = pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;\n\t\t\n\t\t}\n\t\t\n\t\t// Automatic alignment\n\t\tif (align === null) {\n\t\t\tif (axis.isCircular) {\n\t\t\t\tif (angle > 20 && angle < 160) {\n\t\t\t\t\talign = 'left'; // right hemisphere\n\t\t\t\t} else if (angle > 200 && angle < 340) {\n\t\t\t\t\talign = 'right'; // left hemisphere\n\t\t\t\t} else {\n\t\t\t\t\talign = 'center'; // top or bottom\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\talign = 'center';\n\t\t\t}\n\t\t\tlabel.attr({\n\t\t\t\talign: align\n\t\t\t});\n\t\t}\n\t\t\n\t\tret.x += labelOptions.x;\n\t\tret.y += optionsY;\n\t\t\n\t} else {\n\t\tret = proceed.call(this, x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\t}\n\treturn ret;\n});\n\n/**\n * Wrap the getMarkPath function to return the path of the radial marker\n */\nwrap(tickProto, 'getMarkPath', function (proceed, x, y, tickLength, tickWidth, horiz, renderer) {\n\tvar axis = this.axis,\n\t\tendPoint,\n\t\tret;\n\t\t\n\tif (axis.isRadial) {\n\t\tendPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);\n\t\tret = [\n\t\t\t'M',\n\t\t\tx,\n\t\t\ty,\n\t\t\t'L',\n\t\t\tendPoint.x,\n\t\t\tendPoint.y\n\t\t];\n\t} else {\n\t\tret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);\n\t}\n\treturn ret;\n});/* \n * The AreaRangeSeries class\n * \n */\n\n/**\n * Extend the default options with map options\n */\ndefaultPlotOptions.arearange = merge(defaultPlotOptions.area, {\n\tlineWidth: 1,\n\tmarker: null,\n\tthreshold: null,\n\ttooltip: {\n\t\tpointFormat: '<span style=\"color:{series.color}\">{series.name}</span>: <b>{point.low}</b> - <b>{point.high}</b><br/>' \n\t},\n\ttrackByArea: true,\n\tdataLabels: {\n\t\tverticalAlign: null,\n\t\txLow: 0,\n\t\txHigh: 0,\n\t\tyLow: 0,\n\t\tyHigh: 0\t\n\t}\n});\n\n/**\n * Add the series type\n */\nseriesTypes.arearange = Highcharts.extendClass(seriesTypes.area, {\n\ttype: 'arearange',\n\tpointArrayMap: ['low', 'high'],\n\ttoYData: function (point) {\n\t\treturn [point.low, point.high];\n\t},\n\tpointValKey: 'low',\n\t\n\t/**\n\t * Extend getSegments to force null points if the higher value is null. #1703.\n\t */\n\tgetSegments: function () {\n\t\tvar series = this;\n\n\t\teach(series.points, function (point) {\n\t\t\tif (!series.options.connectNulls && (point.low === null || point.high === null)) {\n\t\t\t\tpoint.y = null;\n\t\t\t} else if (point.low === null && point.high !== null) {\n\t\t\t\tpoint.y = point.high;\n\t\t\t}\n\t\t});\n\t\tSeries.prototype.getSegments.call(this);\n\t},\n\t\n\t/**\n\t * Translate data points from raw values x and y to plotX and plotY\n\t */\n\ttranslate: function () {\n\t\tvar series = this,\n\t\t\tyAxis = series.yAxis;\n\n\t\tseriesTypes.area.prototype.translate.apply(series);\n\n\t\t// Set plotLow and plotHigh\n\t\teach(series.points, function (point) {\n\n\t\t\tvar low = point.low,\n\t\t\t\thigh = point.high,\n\t\t\t\tplotY = point.plotY;\n\n\t\t\tif (high === null && low === null) {\n\t\t\t\tpoint.y = null;\n\t\t\t} else if (low === null) {\n\t\t\t\tpoint.plotLow = point.plotY = null;\n\t\t\t\tpoint.plotHigh = yAxis.translate(high, 0, 1, 0, 1);\n\t\t\t} else if (high === null) {\n\t\t\t\tpoint.plotLow = plotY;\n\t\t\t\tpoint.plotHigh = null;\n\t\t\t} else {\n\t\t\t\tpoint.plotLow = plotY;\n\t\t\t\tpoint.plotHigh = yAxis.translate(high, 0, 1, 0, 1);\n\t\t\t}\n\t\t});\n\t},\n\t\n\t/**\n\t * Extend the line series' getSegmentPath method by applying the segment\n\t * path to both lower and higher values of the range\n\t */\n\tgetSegmentPath: function (segment) {\n\t\t\n\t\tvar lowSegment,\n\t\t\thighSegment = [],\n\t\t\ti = segment.length,\n\t\t\tbaseGetSegmentPath = Series.prototype.getSegmentPath,\n\t\t\tpoint,\n\t\t\tlinePath,\n\t\t\tlowerPath,\n\t\t\toptions = this.options,\n\t\t\tstep = options.step,\n\t\t\thigherPath;\n\t\t\t\n\t\t// Remove nulls from low segment\n\t\tlowSegment = HighchartsAdapter.grep(segment, function (point) {\n\t\t\treturn point.plotLow !== null;\n\t\t});\n\t\t\n\t\t// Make a segment with plotX and plotY for the top values\n\t\twhile (i--) {\n\t\t\tpoint = segment[i];\n\t\t\tif (point.plotHigh !== null) {\n\t\t\t\thighSegment.push({\n\t\t\t\t\tplotX: point.plotX,\n\t\t\t\t\tplotY: point.plotHigh\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Get the paths\n\t\tlowerPath = baseGetSegmentPath.call(this, lowSegment);\n\t\tif (step) {\n\t\t\tif (step === true) {\n\t\t\t\tstep = 'left';\n\t\t\t}\n\t\t\toptions.step = { left: 'right', center: 'center', right: 'left' }[step]; // swap for reading in getSegmentPath\n\t\t}\n\t\thigherPath = baseGetSegmentPath.call(this, highSegment);\n\t\toptions.step = step;\n\t\t\n\t\t// Create a line on both top and bottom of the range\n\t\tlinePath = [].concat(lowerPath, higherPath);\n\t\t\n\t\t// For the area path, we need to change the 'move' statement into 'lineTo' or 'curveTo'\n\t\thigherPath[0] = 'L'; // this probably doesn't work for spline\t\t\t\n\t\tthis.areaPath = this.areaPath.concat(lowerPath, higherPath);\n\t\t\n\t\treturn linePath;\n\t},\n\t\n\t/**\n\t * Extend the basic drawDataLabels method by running it for both lower and higher\n\t * values.\n\t */\n\tdrawDataLabels: function () {\n\t\t\n\t\tvar data = this.data,\n\t\t\tlength = data.length,\n\t\t\ti,\n\t\t\toriginalDataLabels = [],\n\t\t\tseriesProto = Series.prototype,\n\t\t\tdataLabelOptions = this.options.dataLabels,\n\t\t\tpoint,\n\t\t\tinverted = this.chart.inverted;\n\t\t\t\n\t\tif (dataLabelOptions.enabled || this._hasPointLabels) {\n\t\t\t\n\t\t\t// Step 1: set preliminary values for plotY and dataLabel and draw the upper labels\n\t\t\ti = length;\n\t\t\twhile (i--) {\n\t\t\t\tpoint = data[i];\n\t\t\t\t\n\t\t\t\t// Set preliminary values\n\t\t\t\tpoint.y = point.high;\n\t\t\t\tpoint.plotY = point.plotHigh;\n\t\t\t\t\n\t\t\t\t// Store original data labels and set preliminary label objects to be picked up \n\t\t\t\t// in the uber method\n\t\t\t\toriginalDataLabels[i] = point.dataLabel;\n\t\t\t\tpoint.dataLabel = point.dataLabelUpper;\n\t\t\t\t\n\t\t\t\t// Set the default offset\n\t\t\t\tpoint.below = false;\n\t\t\t\tif (inverted) {\n\t\t\t\t\tdataLabelOptions.align = 'left';\n\t\t\t\t\tdataLabelOptions.x = dataLabelOptions.xHigh;\t\t\t\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tdataLabelOptions.y = dataLabelOptions.yHigh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tseriesProto.drawDataLabels.apply(this, arguments); // #1209\n\t\t\t\n\t\t\t// Step 2: reorganize and handle data labels for the lower values\n\t\t\ti = length;\n\t\t\twhile (i--) {\n\t\t\t\tpoint = data[i];\n\t\t\t\t\n\t\t\t\t// Move the generated labels from step 1, and reassign the original data labels\n\t\t\t\tpoint.dataLabelUpper = point.dataLabel;\n\t\t\t\tpoint.dataLabel = originalDataLabels[i];\n\t\t\t\t\n\t\t\t\t// Reset values\n\t\t\t\tpoint.y = point.low;\n\t\t\t\tpoint.plotY = point.plotLow;\n\t\t\t\t\n\t\t\t\t// Set the default offset\n\t\t\t\tpoint.below = true;\n\t\t\t\tif (inverted) {\n\t\t\t\t\tdataLabelOptions.align = 'right';\n\t\t\t\t\tdataLabelOptions.x = dataLabelOptions.xLow;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabelOptions.y = dataLabelOptions.yLow;\n\t\t\t\t}\n\t\t\t}\n\t\t\tseriesProto.drawDataLabels.apply(this, arguments);\n\t\t}\n\t\n\t},\n\t\n\talignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n\t\n\tgetSymbol: seriesTypes.column.prototype.getSymbol,\n\t\n\tdrawPoints: noop\n});/**\n * The AreaSplineRangeSeries class\n */\n\ndefaultPlotOptions.areasplinerange = merge(defaultPlotOptions.arearange);\n\n/**\n * AreaSplineRangeSeries object\n */\nseriesTypes.areasplinerange = extendClass(seriesTypes.arearange, {\n\ttype: 'areasplinerange',\n\tgetPointSpline: seriesTypes.spline.prototype.getPointSpline\n});/**\n * The ColumnRangeSeries class\n */\ndefaultPlotOptions.columnrange = merge(defaultPlotOptions.column, defaultPlotOptions.arearange, {\n\tlineWidth: 1,\n\tpointRange: null\n});\n\n/**\n * ColumnRangeSeries object\n */\nseriesTypes.columnrange = extendClass(seriesTypes.arearange, {\n\ttype: 'columnrange',\n\t/**\n\t * Translate data points from raw values x and y to plotX and plotY\n\t */\n\ttranslate: function () {\n\t\tvar series = this,\n\t\t\tyAxis = series.yAxis,\n\t\t\tplotHigh;\n\n\t\tcolProto.translate.apply(series);\n\n\t\t// Set plotLow and plotHigh\n\t\teach(series.points, function (point) {\n\t\t\tvar shapeArgs = point.shapeArgs,\n\t\t\t\tminPointLength = series.options.minPointLength,\n\t\t\t\theightDifference,\n\t\t\t\theight,\n\t\t\t\ty;\n\n\t\t\tpoint.plotHigh = plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n\t\t\tpoint.plotLow = point.plotY;\n\n\t\t\t// adjust shape\n\t\t\ty = plotHigh;\n\t\t\theight = point.plotY - plotHigh;\n\n\t\t\tif (height < minPointLength) {\n\t\t\t\theightDifference = (minPointLength - height);\n\t\t\t\theight += heightDifference;\n\t\t\t\ty -= heightDifference / 2;\n\t\t\t}\n\t\t\tshapeArgs.height = height;\n\t\t\tshapeArgs.y = y;\n\t\t});\n\t},\n\ttrackerGroups: ['group', 'dataLabels'],\n\tdrawGraph: noop,\n\tpointAttrToOptions: colProto.pointAttrToOptions,\n\tdrawPoints: colProto.drawPoints,\n\tdrawTracker: colProto.drawTracker,\n\tanimate: colProto.animate,\n\tgetColumnMetrics: colProto.getColumnMetrics\n});\n/* \n * The GaugeSeries class\n */\n\n\n\n/**\n * Extend the default options\n */\ndefaultPlotOptions.gauge = merge(defaultPlotOptions.line, {\n\tdataLabels: {\n\t\tenabled: true,\n\t\ty: 15,\n\t\tborderWidth: 1,\n\t\tborderColor: 'silver',\n\t\tborderRadius: 3,\n\t\tstyle: {\n\t\t\tfontWeight: 'bold'\n\t\t},\n\t\tverticalAlign: 'top',\n\t\tzIndex: 2\n\t},\n\tdial: {\n\t\t// radius: '80%',\n\t\t// backgroundColor: 'black',\n\t\t// borderColor: 'silver',\n\t\t// borderWidth: 0,\n\t\t// baseWidth: 3,\n\t\t// topWidth: 1,\n\t\t// baseLength: '70%' // of radius\n\t\t// rearLength: '10%'\n\t},\n\tpivot: {\n\t\t//radius: 5,\n\t\t//borderWidth: 0\n\t\t//borderColor: 'silver',\n\t\t//backgroundColor: 'black'\n\t},\n\ttooltip: {\n\t\theaderFormat: ''\n\t},\n\tshowInLegend: false\n});\n\n/**\n * Extend the point object\n */\nvar GaugePoint = Highcharts.extendClass(Highcharts.Point, {\n\t/**\n\t * Don't do any hover colors or anything\n\t */\n\tsetState: function (state) {\n\t\tthis.state = state;\n\t}\n});\n\n\n/**\n * Add the series type\n */\nvar GaugeSeries = {\n\ttype: 'gauge',\n\tpointClass: GaugePoint,\n\t\n\t// chart.angular will be set to true when a gauge series is present, and this will\n\t// be used on the axes\n\tangular: true, \n\tdrawGraph: noop,\n\ttrackerGroups: ['group', 'dataLabels'],\n\t\n\t/**\n\t * Calculate paths etc\n\t */\n\ttranslate: function () {\n\t\t\n\t\tvar series = this,\n\t\t\tyAxis = series.yAxis,\n\t\t\toptions = series.options,\n\t\t\tcenter = yAxis.center;\n\t\t\t\n\t\tseries.generatePoints();\n\t\t\n\t\teach(series.points, function (point) {\n\t\t\t\n\t\t\tvar dialOptions = merge(options.dial, point.dial),\n\t\t\t\tradius = (pInt(pick(dialOptions.radius, 80)) * center[2]) / 200,\n\t\t\t\tbaseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) / 100,\n\t\t\t\trearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) / 100,\n\t\t\t\tbaseWidth = dialOptions.baseWidth || 3,\n\t\t\t\ttopWidth = dialOptions.topWidth || 1,\n\t\t\t\trotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);\n\n\t\t\t// Handle the wrap option\n\t\t\tif (options.wrap === false) {\n\t\t\t\trotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));\n\t\t\t}\n\t\t\trotation = rotation * 180 / Math.PI;\n\t\t\t\t\n\t\t\tpoint.shapeType = 'path';\n\t\t\tpoint.shapeArgs = {\n\t\t\t\td: dialOptions.path || [\n\t\t\t\t\t'M', \n\t\t\t\t\t-rearLength, -baseWidth / 2, \n\t\t\t\t\t'L', \n\t\t\t\t\tbaseLength, -baseWidth / 2,\n\t\t\t\t\tradius, -topWidth / 2,\n\t\t\t\t\tradius, topWidth / 2,\n\t\t\t\t\tbaseLength, baseWidth / 2,\n\t\t\t\t\t-rearLength, baseWidth / 2,\n\t\t\t\t\t'z'\n\t\t\t\t],\n\t\t\t\ttranslateX: center[0],\n\t\t\t\ttranslateY: center[1],\n\t\t\t\trotation: rotation\n\t\t\t};\n\t\t\t\n\t\t\t// Positions for data label\n\t\t\tpoint.plotX = center[0];\n\t\t\tpoint.plotY = center[1];\n\t\t});\n\t},\n\t\n\t/**\n\t * Draw the points where each point is one needle\n\t */\n\tdrawPoints: function () {\n\t\t\n\t\tvar series = this,\n\t\t\tcenter = series.yAxis.center,\n\t\t\tpivot = series.pivot,\n\t\t\toptions = series.options,\n\t\t\tpivotOptions = options.pivot,\n\t\t\trenderer = series.chart.renderer;\n\t\t\n\t\teach(series.points, function (point) {\n\t\t\t\n\t\t\tvar graphic = point.graphic,\n\t\t\t\tshapeArgs = point.shapeArgs,\n\t\t\t\td = shapeArgs.d,\n\t\t\t\tdialOptions = merge(options.dial, point.dial); // #1233\n\t\t\t\n\t\t\tif (graphic) {\n\t\t\t\tgraphic.animate(shapeArgs);\n\t\t\t\tshapeArgs.d = d; // animate alters it\n\t\t\t} else {\n\t\t\t\tpoint.graphic = renderer[point.shapeType](shapeArgs)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: dialOptions.borderColor || 'none',\n\t\t\t\t\t\t'stroke-width': dialOptions.borderWidth || 0,\n\t\t\t\t\t\tfill: dialOptions.backgroundColor || 'black',\n\t\t\t\t\t\trotation: shapeArgs.rotation // required by VML when animation is false\n\t\t\t\t\t})\n\t\t\t\t\t.add(series.group);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Add or move the pivot\n\t\tif (pivot) {\n\t\t\tpivot.animate({ // #1235\n\t\t\t\ttranslateX: center[0],\n\t\t\t\ttranslateY: center[1]\n\t\t\t});\n\t\t} else {\n\t\t\tseries.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))\n\t\t\t\t.attr({\n\t\t\t\t\t'stroke-width': pivotOptions.borderWidth || 0,\n\t\t\t\t\tstroke: pivotOptions.borderColor || 'silver',\n\t\t\t\t\tfill: pivotOptions.backgroundColor || 'black'\n\t\t\t\t})\n\t\t\t\t.translate(center[0], center[1])\n\t\t\t\t.add(series.group);\n\t\t}\n\t},\n\t\n\t/**\n\t * Animate the arrow up from startAngle\n\t */\n\tanimate: function (init) {\n\t\tvar series = this;\n\n\t\tif (!init) {\n\t\t\teach(series.points, function (point) {\n\t\t\t\tvar graphic = point.graphic;\n\n\t\t\t\tif (graphic) {\n\t\t\t\t\t// start value\n\t\t\t\t\tgraphic.attr({\n\t\t\t\t\t\trotation: series.yAxis.startAngleRad * 180 / Math.PI\n\t\t\t\t\t});\n\n\t\t\t\t\t// animate\n\t\t\t\t\tgraphic.animate({\n\t\t\t\t\t\trotation: point.shapeArgs.rotation\n\t\t\t\t\t}, series.options.animation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// delete this function to allow it only once\n\t\t\tseries.animate = null;\n\t\t}\n\t},\n\t\n\trender: function () {\n\t\tthis.group = this.plotGroup(\n\t\t\t'group', \n\t\t\t'series', \n\t\t\tthis.visible ? 'visible' : 'hidden', \n\t\t\tthis.options.zIndex, \n\t\t\tthis.chart.seriesGroup\n\t\t);\n\t\tseriesTypes.pie.prototype.render.call(this);\n\t\tthis.group.clip(this.chart.clipRect);\n\t},\n\t\n\tsetData: seriesTypes.pie.prototype.setData,\n\tdrawTracker: seriesTypes.column.prototype.drawTracker\n};\nseriesTypes.gauge = Highcharts.extendClass(seriesTypes.line, GaugeSeries);/* ****************************************************************************\n * Start Box plot series code\t\t\t\t\t\t\t\t\t\t\t      *\n *****************************************************************************/\n\n// Set default options\ndefaultPlotOptions.boxplot = merge(defaultPlotOptions.column, {\n\tfillColor: '#FFFFFF',\n\tlineWidth: 1,\n\t//medianColor: null,\n\tmedianWidth: 2,\n\tstates: {\n\t\thover: {\n\t\t\tbrightness: -0.3\n\t\t}\n\t},\n\t//stemColor: null,\n\t//stemDashStyle: 'solid'\n\t//stemWidth: null,\n\tthreshold: null,\n\ttooltip: {\n\t\tpointFormat: '<span style=\"color:{series.color};font-weight:bold\">{series.name}</span><br/>' +\n\t\t\t'Maximum: {point.high}<br/>' +\n\t\t\t'Upper quartile: {point.q3}<br/>' +\n\t\t\t'Median: {point.median}<br/>' +\n\t\t\t'Lower quartile: {point.q1}<br/>' +\n\t\t\t'Minimum: {point.low}<br/>'\n\t\t\t\n\t},\n\t//whiskerColor: null,\n\twhiskerLength: '50%',\n\twhiskerWidth: 2\n});\n\n// Create the series object\nseriesTypes.boxplot = extendClass(seriesTypes.column, {\n\ttype: 'boxplot',\n\tpointArrayMap: ['low', 'q1', 'median', 'q3', 'high'], // array point configs are mapped to this\n\ttoYData: function (point) { // return a plain array for speedy calculation\n\t\treturn [point.low, point.q1, point.median, point.q3, point.high];\n\t},\n\tpointValKey: 'high', // defines the top of the tracker\n\t\n\t/**\n\t * One-to-one mapping from options to SVG attributes\n\t */\n\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\tfill: 'fillColor',\n\t\tstroke: 'color',\n\t\t'stroke-width': 'lineWidth'\n\t},\n\t\n\t/**\n\t * Disable data labels for box plot\n\t */\n\tdrawDataLabels: noop,\n\n\t/**\n\t * Translate data points from raw values x and y to plotX and plotY\n\t */\n\ttranslate: function () {\n\t\tvar series = this,\n\t\t\tyAxis = series.yAxis,\n\t\t\tpointArrayMap = series.pointArrayMap;\n\n\t\tseriesTypes.column.prototype.translate.apply(series);\n\n\t\t// do the translation on each point dimension\n\t\teach(series.points, function (point) {\n\t\t\teach(pointArrayMap, function (key) {\n\t\t\t\tif (point[key] !== null) {\n\t\t\t\t\tpoint[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Draw the data points\n\t */\n\tdrawPoints: function () {\n\t\tvar series = this,  //state = series.state,\n\t\t\tpoints = series.points,\n\t\t\toptions = series.options,\n\t\t\tchart = series.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tpointAttr,\n\t\t\tq1Plot,\n\t\t\tq3Plot,\n\t\t\thighPlot,\n\t\t\tlowPlot,\n\t\t\tmedianPlot,\n\t\t\tcrispCorr,\n\t\t\tcrispX,\n\t\t\tgraphic,\n\t\t\tstemPath,\n\t\t\tstemAttr,\n\t\t\tboxPath,\n\t\t\twhiskersPath,\n\t\t\twhiskersAttr,\n\t\t\tmedianPath,\n\t\t\tmedianAttr,\n\t\t\twidth,\n\t\t\tleft,\n\t\t\tright,\n\t\t\thalfWidth,\n\t\t\tshapeArgs,\n\t\t\tcolor,\n\t\t\tdoQuartiles = series.doQuartiles !== false, // error bar inherits this series type but doesn't do quartiles\n\t\t\twhiskerLength = parseInt(series.options.whiskerLength, 10) / 100;\n\n\n\t\teach(points, function (point) {\n\n\t\t\tgraphic = point.graphic;\n\t\t\tshapeArgs = point.shapeArgs; // the box\n\t\t\tstemAttr = {};\n\t\t\twhiskersAttr = {};\n\t\t\tmedianAttr = {};\n\t\t\tcolor = point.color || series.color;\n\t\t\t\n\t\t\tif (point.plotY !== UNDEFINED) {\n\n\t\t\t\tpointAttr = point.pointAttr[point.selected ? 'selected' : ''];\n\n\t\t\t\t// crisp vector coordinates\n\t\t\t\twidth = shapeArgs.width;\n\t\t\t\tleft = mathFloor(shapeArgs.x);\n\t\t\t\tright = left + width;\n\t\t\t\thalfWidth = mathRound(width / 2);\n\t\t\t\t//crispX = mathRound(left + halfWidth) + crispCorr;\n\t\t\t\tq1Plot = mathFloor(doQuartiles ? point.q1Plot : point.lowPlot);// + crispCorr;\n\t\t\t\tq3Plot = mathFloor(doQuartiles ? point.q3Plot : point.lowPlot);// + crispCorr;\n\t\t\t\thighPlot = mathFloor(point.highPlot);// + crispCorr;\n\t\t\t\tlowPlot = mathFloor(point.lowPlot);// + crispCorr;\n\t\t\t\t\n\t\t\t\t// Stem attributes\n\t\t\t\tstemAttr.stroke = point.stemColor || options.stemColor || color;\n\t\t\t\tstemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n\t\t\t\tstemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle;\n\t\t\t\t\n\t\t\t\t// Whiskers attributes\n\t\t\t\twhiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color;\n\t\t\t\twhiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n\t\t\t\t\n\t\t\t\t// Median attributes\n\t\t\t\tmedianAttr.stroke = point.medianColor || options.medianColor || color;\n\t\t\t\tmedianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// The stem\n\t\t\t\tcrispCorr = (stemAttr['stroke-width'] % 2) / 2;\n\t\t\t\tcrispX = left + halfWidth + crispCorr;\t\t\t\t\n\t\t\t\tstemPath = [\n\t\t\t\t\t// stem up\n\t\t\t\t\t'M',\n\t\t\t\t\tcrispX, q3Plot,\n\t\t\t\t\t'L',\n\t\t\t\t\tcrispX, highPlot,\n\t\t\t\t\t\n\t\t\t\t\t// stem down\n\t\t\t\t\t'M',\n\t\t\t\t\tcrispX, q1Plot,\n\t\t\t\t\t'L',\n\t\t\t\t\tcrispX, lowPlot,\n\t\t\t\t\t'z'\n\t\t\t\t];\n\t\t\t\t\n\t\t\t\t// The box\n\t\t\t\tif (doQuartiles) {\n\t\t\t\t\tcrispCorr = (pointAttr['stroke-width'] % 2) / 2;\n\t\t\t\t\tcrispX = mathFloor(crispX) + crispCorr;\n\t\t\t\t\tq1Plot = mathFloor(q1Plot) + crispCorr;\n\t\t\t\t\tq3Plot = mathFloor(q3Plot) + crispCorr;\n\t\t\t\t\tleft += crispCorr;\n\t\t\t\t\tright += crispCorr;\n\t\t\t\t\tboxPath = [\n\t\t\t\t\t\t'M',\n\t\t\t\t\t\tleft, q3Plot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tleft, q1Plot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tright, q1Plot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tright, q3Plot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tleft, q3Plot,\n\t\t\t\t\t\t'z'\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// The whiskers\n\t\t\t\tif (whiskerLength) {\n\t\t\t\t\tcrispCorr = (whiskersAttr['stroke-width'] % 2) / 2;\n\t\t\t\t\thighPlot = highPlot + crispCorr;\n\t\t\t\t\tlowPlot = lowPlot + crispCorr;\n\t\t\t\t\twhiskersPath = [\n\t\t\t\t\t\t// High whisker\n\t\t\t\t\t\t'M',\n\t\t\t\t\t\tcrispX - halfWidth * whiskerLength, \n\t\t\t\t\t\thighPlot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tcrispX + halfWidth * whiskerLength, \n\t\t\t\t\t\thighPlot,\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Low whisker\n\t\t\t\t\t\t'M',\n\t\t\t\t\t\tcrispX - halfWidth * whiskerLength, \n\t\t\t\t\t\tlowPlot,\n\t\t\t\t\t\t'L',\n\t\t\t\t\t\tcrispX + halfWidth * whiskerLength, \n\t\t\t\t\t\tlowPlot\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// The median\n\t\t\t\tcrispCorr = (medianAttr['stroke-width'] % 2) / 2;\t\t\t\t\n\t\t\t\tmedianPlot = mathRound(point.medianPlot) + crispCorr;\n\t\t\t\tmedianPath = [\n\t\t\t\t\t'M',\n\t\t\t\t\tleft, \n\t\t\t\t\tmedianPlot,\n\t\t\t\t\t'L',\n\t\t\t\t\tright, \n\t\t\t\t\tmedianPlot,\n\t\t\t\t\t'z'\n\t\t\t\t];\n\t\t\t\t\n\t\t\t\t// Create or update the graphics\n\t\t\t\tif (graphic) { // update\n\t\t\t\t\t\n\t\t\t\t\tpoint.stem.animate({ d: stemPath });\n\t\t\t\t\tif (whiskerLength) {\n\t\t\t\t\t\tpoint.whiskers.animate({ d: whiskersPath });\n\t\t\t\t\t}\n\t\t\t\t\tif (doQuartiles) {\n\t\t\t\t\t\tpoint.box.animate({ d: boxPath });\n\t\t\t\t\t}\n\t\t\t\t\tpoint.medianShape.animate({ d: medianPath });\n\t\t\t\t\t\n\t\t\t\t} else { // create new\n\t\t\t\t\tpoint.graphic = graphic = renderer.g()\n\t\t\t\t\t\t.add(series.group);\n\t\t\t\t\t\n\t\t\t\t\tpoint.stem = renderer.path(stemPath)\n\t\t\t\t\t\t.attr(stemAttr)\n\t\t\t\t\t\t.add(graphic);\n\t\t\t\t\t\t\n\t\t\t\t\tif (whiskerLength) {\n\t\t\t\t\t\tpoint.whiskers = renderer.path(whiskersPath) \n\t\t\t\t\t\t\t.attr(whiskersAttr)\n\t\t\t\t\t\t\t.add(graphic);\n\t\t\t\t\t}\n\t\t\t\t\tif (doQuartiles) {\n\t\t\t\t\t\tpoint.box = renderer.path(boxPath)\n\t\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t\t.add(graphic);\n\t\t\t\t\t}\t\n\t\t\t\t\tpoint.medianShape = renderer.path(medianPath)\n\t\t\t\t\t\t.attr(medianAttr)\n\t\t\t\t\t\t.add(graphic);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t}\n\n\n});\n\n/* ****************************************************************************\n * End Box plot series code\t\t\t\t\t\t\t\t\t\t\t\t*\n *****************************************************************************/\n/* ****************************************************************************\n * Start error bar series code                                                *\n *****************************************************************************/\n\n// 1 - set default options\ndefaultPlotOptions.errorbar = merge(defaultPlotOptions.boxplot, {\n\tcolor: '#000000',\n\tgrouping: false,\n\tlinkedTo: ':previous',\n\ttooltip: {\n\t\tpointFormat: defaultPlotOptions.arearange.tooltip.pointFormat\n\t},\n\twhiskerWidth: null\n});\n\n// 2 - Create the series object\nseriesTypes.errorbar = extendClass(seriesTypes.boxplot, {\n\ttype: 'errorbar',\n\tpointArrayMap: ['low', 'high'], // array point configs are mapped to this\n\ttoYData: function (point) { // return a plain array for speedy calculation\n\t\treturn [point.low, point.high];\n\t},\n\tpointValKey: 'high', // defines the top of the tracker\n\tdoQuartiles: false,\n\n\t/**\n\t * Get the width and X offset, either on top of the linked series column\n\t * or standalone\n\t */\n\tgetColumnMetrics: function () {\n\t\treturn (this.linkedParent && this.linkedParent.columnMetrics) || \n\t\t\tseriesTypes.column.prototype.getColumnMetrics.call(this);\n\t}\n});\n\n/* ****************************************************************************\n * End error bar series code                                                  *\n *****************************************************************************/\n/* ****************************************************************************\n * Start Waterfall series code                                                *\n *****************************************************************************/\n\n// 1 - set default options\ndefaultPlotOptions.waterfall = merge(defaultPlotOptions.column, {\n\tlineWidth: 1,\n\tlineColor: '#333',\n\tdashStyle: 'dot',\n\tborderColor: '#333'\n});\n\n\n// 2 - Create the series object\nseriesTypes.waterfall = extendClass(seriesTypes.column, {\n\ttype: 'waterfall',\n\n\tupColorProp: 'fill',\n\n\tpointArrayMap: ['low', 'y'],\n\n\tpointValKey: 'y',\n\n\t/**\n\t * Init waterfall series, force stacking\n\t */\n\tinit: function (chart, options) {\n\t\t// force stacking\n\t\toptions.stacking = true;\n\n\t\tseriesTypes.column.prototype.init.call(this, chart, options);\n\t},\n\n\n\t/**\n\t * Translate data points from raw values\n\t */\n\ttranslate: function () {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\taxis = series.yAxis,\n\t\t\tlen,\n\t\t\ti,\n\t\t\tpoints,\n\t\t\tpoint,\n\t\t\tshapeArgs,\n\t\t\tstack,\n\t\t\ty,\n\t\t\tpreviousY,\n\t\t\tstackPoint,\n\t\t\tthreshold = options.threshold,\n\t\t\tcrispCorr = (options.borderWidth % 2) / 2;\n\n\t\t// run column series translate\n\t\tseriesTypes.column.prototype.translate.apply(this);\n\n\t\tpreviousY = threshold;\n\t\tpoints = series.points;\n\n\t\tfor (i = 0, len = points.length; i < len; i++) {\n\t\t\t// cache current point object\n\t\t\tpoint = points[i];\n\t\t\tshapeArgs = point.shapeArgs;\n\n\t\t\t// get current stack\n\t\t\tstack = series.getStack(i);\n\t\t\tstackPoint = stack.points[series.index];\n\n\t\t\t// override point value for sums\n\t\t\tif (isNaN(point.y)) {\n\t\t\t\tpoint.y = series.yData[i];\n\t\t\t}\n\n\t\t\t// up points\n\t\t\ty = mathMax(previousY, previousY + point.y) + stackPoint[0];\n\t\t\tshapeArgs.y = axis.translate(y, 0, 1);\n\n\n\t\t\t// sum points\n\t\t\tif (point.isSum || point.isIntermediateSum) {\n\t\t\t\tshapeArgs.y = axis.translate(stackPoint[1], 0, 1);\n\t\t\t\tshapeArgs.height = axis.translate(stackPoint[0], 0, 1) - shapeArgs.y;\n\n\t\t\t// if it's not the sum point, update previous stack end position\n\t\t\t} else {\n\t\t\t\tpreviousY += stack.total;\n\t\t\t}\n\n\t\t\t// negative points\n\t\t\tif (shapeArgs.height < 0) {\n\t\t\t\tshapeArgs.y += shapeArgs.height;\n\t\t\t\tshapeArgs.height *= -1;\n\t\t\t}\n\n\t\t\tpoint.plotY = shapeArgs.y = mathRound(shapeArgs.y) - crispCorr;\n\t\t\tshapeArgs.height = mathRound(shapeArgs.height);\n\t\t\tpoint.yBottom = shapeArgs.y + shapeArgs.height;\n\t\t}\n\t},\n\n\t/**\n\t * Call default processData then override yData to reflect waterfall's extremes on yAxis\n\t */\n\tprocessData: function (force) {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tyData = series.yData,\n\t\t\tpoints = series.points,\n\t\t\tpoint,\n\t\t\tdataLength = yData.length,\n\t\t\tthreshold = options.threshold || 0,\n\t\t\tsubSum,\n\t\t\tsum,\n\t\t\tdataMin,\n\t\t\tdataMax,\n\t\t\ty,\n\t\t\ti;\n\n\t\tsum = subSum = dataMin = dataMax = threshold;\n\n\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\ty = yData[i];\n\t\t\tpoint = points ? points[i] : {};\n\n\t\t\tif (y === \"sum\" || point.isSum) {\n\t\t\t\tyData[i] = sum;\n\t\t\t} else if (y === \"intermediateSum\" || point.isIntermediateSum) {\n\t\t\t\tyData[i] = subSum;\n\t\t\t\tsubSum = threshold;\n\t\t\t} else {\n\t\t\t\tsum += y;\n\t\t\t\tsubSum += y;\n\t\t\t}\n\t\t\tdataMin = Math.min(sum, dataMin);\n\t\t\tdataMax = Math.max(sum, dataMax);\n\t\t}\n\n\t\tSeries.prototype.processData.call(this, force);\n\n\t\t// Record extremes\n\t\tseries.dataMin = dataMin;\n\t\tseries.dataMax = dataMax;\n\t},\n\n\t/**\n\t * Return y value or string if point is sum\n\t */\n\ttoYData: function (pt) {\n\t\tif (pt.isSum) {\n\t\t\treturn \"sum\";\n\t\t} else if (pt.isIntermediateSum) {\n\t\t\treturn \"intermediateSum\";\n\t\t}\n\n\t\treturn pt.y;\n\t},\n\n\t/**\n\t * Postprocess mapping between options and SVG attributes\n\t */\n\tgetAttribs: function () {\n\t\tseriesTypes.column.prototype.getAttribs.apply(this, arguments);\n\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tstateOptions = options.states,\n\t\t\tupColor = options.upColor || series.color,\n\t\t\thoverColor = Highcharts.Color(upColor).brighten(0.1).get(),\n\t\t\tseriesDownPointAttr = merge(series.pointAttr),\n\t\t\tupColorProp = series.upColorProp;\n\n\t\tseriesDownPointAttr[''][upColorProp] = upColor;\n\t\tseriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || hoverColor;\n\t\tseriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;\n\n\t\teach(series.points, function (point) {\n\t\t\tif (point.y > 0 && !point.color) {\n\t\t\t\tpoint.pointAttr = seriesDownPointAttr;\n\t\t\t\tpoint.color = upColor;\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Draw columns' connector lines\n\t */\n\tgetGraphPath: function () {\n\n\t\tvar data = this.data,\n\t\t\tlength = data.length,\n\t\t\tlineWidth = this.options.lineWidth + this.options.borderWidth,\n\t\t\tnormalizer = mathRound(lineWidth) % 2 / 2,\n\t\t\tpath = [],\n\t\t\tM = 'M',\n\t\t\tL = 'L',\n\t\t\tprevArgs,\n\t\t\tpointArgs,\n\t\t\ti,\n\t\t\td;\n\n\t\tfor (i = 1; i < length; i++) {\n\t\t\tpointArgs = data[i].shapeArgs;\n\t\t\tprevArgs = data[i - 1].shapeArgs;\n\n\t\t\td = [\n\t\t\t\tM,\n\t\t\t\tprevArgs.x + prevArgs.width, prevArgs.y + normalizer,\n\t\t\t\tL,\n\t\t\t\tpointArgs.x, prevArgs.y + normalizer\n\t\t\t];\n\n\t\t\tif (data[i - 1].y < 0) {\n\t\t\t\td[2] += prevArgs.height;\n\t\t\t\td[5] += prevArgs.height;\n\t\t\t}\n\n\t\t\tpath = path.concat(d);\n\t\t}\n\n\t\treturn path;\n\t},\n\n\t/**\n\t * Extremes are recorded in processData\n\t */\n\tgetExtremes: noop,\n\n\t/**\n\t * Return stack for given index\n\t */\n\tgetStack: function (i) {\n\t\tvar axis = this.yAxis,\n\t\t\tstacks = axis.stacks,\n\t\t\tkey = this.stackKey;\n\n\t\tif (this.processedYData[i] < this.options.threshold) {\n\t\t\tkey = '-' + key;\n\t\t}\n\n\t\treturn stacks[key][i];\n\t},\n\n\tdrawGraph: Series.prototype.drawGraph\n});\n\n/* ****************************************************************************\n * End Waterfall series code                                                  *\n *****************************************************************************/\n/* ****************************************************************************\n * Start Bubble series code\t\t\t\t\t\t\t\t\t\t\t          *\n *****************************************************************************/\n\n// 1 - set default options\ndefaultPlotOptions.bubble = merge(defaultPlotOptions.scatter, {\n\tdataLabels: {\n\t\tinside: true,\n\t\tstyle: {\n\t\t\tcolor: 'white',\n\t\t\ttextShadow: '0px 0px 3px black'\n\t\t},\n\t\tverticalAlign: 'middle'\n\t},\n\t// displayNegative: true,\n\tmarker: {\n\t\t// fillOpacity: 0.5,\n\t\tlineColor: null, // inherit from series.color\n\t\tlineWidth: 1\n\t},\n\tminSize: 8,\n\tmaxSize: '20%',\n\t// negativeColor: null,\n\ttooltip: {\n\t\tpointFormat: '({point.x}, {point.y}), Size: {point.z}'\n\t},\n\tturboThreshold: 0,\n\tzThreshold: 0\n});\n\n// 2 - Create the series object\nseriesTypes.bubble = extendClass(seriesTypes.scatter, {\n\ttype: 'bubble',\n\tpointArrayMap: ['y', 'z'],\n\ttrackerGroups: ['group', 'dataLabelsGroup'],\n\t\n\t/**\n\t * Mapping between SVG attributes and the corresponding options\n\t */\n\tpointAttrToOptions: { \n\t\tstroke: 'lineColor',\n\t\t'stroke-width': 'lineWidth',\n\t\tfill: 'fillColor'\n\t},\n\t\n\t/**\n\t * Apply the fillOpacity to all fill positions\n\t */\n\tapplyOpacity: function (fill) {\n\t\tvar markerOptions = this.options.marker,\n\t\t\tfillOpacity = pick(markerOptions.fillOpacity, 0.5);\n\t\t\n\t\t// When called from Legend.colorizeItem, the fill isn't predefined\n\t\tfill = fill || markerOptions.fillColor || this.color; \n\t\t\n\t\tif (fillOpacity !== 1) {\n\t\t\tfill = Highcharts.Color(fill).setOpacity(fillOpacity).get('rgba');\n\t\t}\n\t\treturn fill;\n\t},\n\t\n\t/**\n\t * Extend the convertAttribs method by applying opacity to the fill\n\t */\n\tconvertAttribs: function () {\n\t\tvar obj = Series.prototype.convertAttribs.apply(this, arguments);\n\t\t\n\t\tobj.fill = this.applyOpacity(obj.fill);\n\t\t\n\t\treturn obj;\n\t},\n\n\t/**\n\t * Get the radius for each point based on the minSize, maxSize and each point's Z value. This\n\t * must be done prior to Series.translate because the axis needs to add padding in \n\t * accordance with the point sizes.\n\t */\n\tgetRadii: function (zMin, zMax, minSize, maxSize) {\n\t\tvar len,\n\t\t\ti,\n\t\t\tpos,\n\t\t\tzData = this.zData,\n\t\t\tradii = [],\n\t\t\tzRange;\n\t\t\n\t\t// Set the shape type and arguments to be picked up in drawPoints\n\t\tfor (i = 0, len = zData.length; i < len; i++) {\n\t\t\tzRange = zMax - zMin;\n\t\t\tpos = zRange > 0 ? // relative size, a number between 0 and 1\n\t\t\t\t(zData[i] - zMin) / (zMax - zMin) : \n\t\t\t\t0.5;\n\t\t\tradii.push(math.ceil(minSize + pos * (maxSize - minSize)) / 2);\n\t\t}\n\t\tthis.radii = radii;\n\t},\n\t\n\t/**\n\t * Perform animation on the bubbles\n\t */\n\tanimate: function (init) {\n\t\tvar animation = this.options.animation;\n\t\t\n\t\tif (!init) { // run the animation\n\t\t\teach(this.points, function (point) {\n\t\t\t\tvar graphic = point.graphic,\n\t\t\t\t\tshapeArgs = point.shapeArgs;\n\n\t\t\t\tif (graphic && shapeArgs) {\n\t\t\t\t\t// start values\n\t\t\t\t\tgraphic.attr('r', 1);\n\n\t\t\t\t\t// animate\n\t\t\t\t\tgraphic.animate({\n\t\t\t\t\t\tr: shapeArgs.r\n\t\t\t\t\t}, animation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// delete this function to allow it only once\n\t\t\tthis.animate = null;\n\t\t}\n\t},\n\t\n\t/**\n\t * Extend the base translate method to handle bubble size\n\t */\n\ttranslate: function () {\n\t\t\n\t\tvar i,\n\t\t\tdata = this.data,\n\t\t\tpoint,\n\t\t\tradius,\n\t\t\tradii = this.radii;\n\t\t\n\t\t// Run the parent method\n\t\tseriesTypes.scatter.prototype.translate.call(this);\n\t\t\n\t\t// Set the shape type and arguments to be picked up in drawPoints\n\t\ti = data.length;\n\t\t\n\t\twhile (i--) {\n\t\t\tpoint = data[i];\n\t\t\tradius = radii ? radii[i] : 0; // #1737\n\n\t\t\t// Flag for negativeColor to be applied in Series.js\n\t\t\tpoint.negative = point.z < (this.options.zThreshold || 0);\n\t\t\t\n\t\t\tif (radius >= this.minPxSize / 2) {\n\t\t\t\t// Shape arguments\n\t\t\t\tpoint.shapeType = 'circle';\n\t\t\t\tpoint.shapeArgs = {\n\t\t\t\t\tx: point.plotX,\n\t\t\t\t\ty: point.plotY,\n\t\t\t\t\tr: radius\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// Alignment box for the data label\n\t\t\t\tpoint.dlBox = {\n\t\t\t\t\tx: point.plotX - radius,\n\t\t\t\t\ty: point.plotY - radius,\n\t\t\t\t\twidth: 2 * radius,\n\t\t\t\t\theight: 2 * radius\n\t\t\t\t};\n\t\t\t} else { // below zThreshold\n\t\t\t\tpoint.shapeArgs = point.plotY = point.dlBox = UNDEFINED; // #1691\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Get the series' symbol in the legend\n\t * \n\t * @param {Object} legend The legend object\n\t * @param {Object} item The series (this) or point\n\t */\n\tdrawLegendSymbol: function (legend, item) {\n\t\tvar radius = pInt(legend.itemStyle.fontSize) / 2;\n\t\t\n\t\titem.legendSymbol = this.chart.renderer.circle(\n\t\t\tradius,\n\t\t\tlegend.baseline - radius,\n\t\t\tradius\n\t\t).attr({\n\t\t\tzIndex: 3\n\t\t}).add(item.legendGroup);\n\t\titem.legendSymbol.isMarker = true;\t\n\t\t\n\t},\n\t\n\tdrawPoints: seriesTypes.column.prototype.drawPoints,\n\talignDataLabel: seriesTypes.column.prototype.alignDataLabel\n});\n\n/**\n * Add logic to pad each axis with the amount of pixels\n * necessary to avoid the bubbles to overflow.\n */\nAxis.prototype.beforePadding = function () {\n\tvar axis = this,\n\t\taxisLength = this.len,\n\t\tchart = this.chart,\n\t\tpxMin = 0, \n\t\tpxMax = axisLength,\n\t\tisXAxis = this.isXAxis,\n\t\tdataKey = isXAxis ? 'xData' : 'yData',\n\t\tmin = this.min,\n\t\textremes = {},\n\t\tsmallestSize = math.min(chart.plotWidth, chart.plotHeight),\n\t\tzMin = Number.MAX_VALUE,\n\t\tzMax = -Number.MAX_VALUE,\n\t\trange = this.max - min,\n\t\ttransA = axisLength / range,\n\t\tactiveSeries = [];\n\n\t// Handle padding on the second pass, or on redraw\n\tif (this.tickPositions) {\n\t\teach(this.series, function (series) {\n\n\t\t\tvar seriesOptions = series.options,\n\t\t\t\tzData;\n\n\t\t\tif (series.type === 'bubble' && series.visible) {\n\n\t\t\t\t// Correction for #1673\n\t\t\t\taxis.allowZoomOutside = true;\n\n\t\t\t\t// Cache it\n\t\t\t\tactiveSeries.push(series);\n\n\t\t\t\tif (isXAxis) { // because X axis is evaluated first\n\t\t\t\t\n\t\t\t\t\t// For each series, translate the size extremes to pixel values\n\t\t\t\t\teach(['minSize', 'maxSize'], function (prop) {\n\t\t\t\t\t\tvar length = seriesOptions[prop],\n\t\t\t\t\t\t\tisPercent = /%$/.test(length);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlength = pInt(length);\n\t\t\t\t\t\textremes[prop] = isPercent ?\n\t\t\t\t\t\t\tsmallestSize * length / 100 :\n\t\t\t\t\t\t\tlength;\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t\tseries.minPxSize = extremes.minSize;\n\t\t\t\t\t\n\t\t\t\t\t// Find the min and max Z\n\t\t\t\t\tzData = series.zData;\n\t\t\t\t\tif (zData.length) { // #1735\n\t\t\t\t\t\tzMin = math.min(\n\t\t\t\t\t\t\tzMin,\n\t\t\t\t\t\t\tmath.max(\n\t\t\t\t\t\t\t\tarrayMin(zData), \n\t\t\t\t\t\t\t\tseriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tzMax = math.max(zMax, arrayMax(zData));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\teach(activeSeries, function (series) {\n\n\t\t\tvar data = series[dataKey],\n\t\t\t\ti = data.length,\n\t\t\t\tradius;\n\n\t\t\tif (isXAxis) {\n\t\t\t\tseries.getRadii(zMin, zMax, extremes.minSize, extremes.maxSize);\n\t\t\t}\n\t\t\t\n\t\t\tif (range > 0) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\tradius = series.radii[i];\n\t\t\t\t\tpxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n\t\t\t\t\tpxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (range > 0 && pick(this.options.min, this.userMin) === UNDEFINED && pick(this.options.max, this.userMax) === UNDEFINED) {\n\t\t\tpxMax -= axisLength;\n\t\t\ttransA *= (axisLength + pxMin - pxMax) / axisLength;\n\t\t\tthis.min += pxMin / transA;\n\t\t\tthis.max += pxMax / transA;\n\t\t}\n\t}\n};\n\n/* ****************************************************************************\n * End Bubble series code                                                     *\n *****************************************************************************/\n/**\n * Extensions for polar charts. Additionally, much of the geometry required for polar charts is\n * gathered in RadialAxes.js.\n * \n */\n\nvar seriesProto = Series.prototype,\n\tpointerProto = Highcharts.Pointer.prototype;\n\n\n\n/**\n * Translate a point's plotX and plotY from the internal angle and radius measures to \n * true plotX, plotY coordinates\n */\nseriesProto.toXY = function (point) {\n\tvar xy,\n\t\tchart = this.chart,\n\t\tplotX = point.plotX,\n\t\tplotY = point.plotY;\n\t\n\t// Save rectangular plotX, plotY for later computation\n\tpoint.rectPlotX = plotX;\n\tpoint.rectPlotY = plotY;\n\t\n\t// Record the angle in degrees for use in tooltip\n\tpoint.clientX = ((plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle) % 360;\n\t\n\t// Find the polar plotX and plotY\n\txy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);\n\tpoint.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n\tpoint.plotY = point.polarPlotY = xy.y - chart.plotTop;\n};\n\n/** \n * Order the tooltip points to get the mouse capture ranges correct. #1915. \n */\nseriesProto.orderTooltipPoints = function (points) {\n\tif (this.chart.polar) {\n\t\tpoints.sort(function (a, b) {\n\t\t\treturn a.clientX - b.clientX;\n\t\t});\n\n\t\t// Wrap mouse tracking around to capture movement on the segment to the left\n\t\t// of the north point (#1469, #2093).\n\t\tif (points[0]) {\n\t\t\tpoints[0].wrappedClientX = points[0].clientX + 360;\n\t\t\tpoints.push(points[0]);\n\t\t}\n\t}\n};\n\n\n/**\n * Add some special init logic to areas and areasplines\n */\nfunction initArea(proceed, chart, options) {\n\tproceed.call(this, chart, options);\n\tif (this.chart.polar) {\n\t\t\n\t\t/**\n\t\t * Overridden method to close a segment path. While in a cartesian plane the area \n\t\t * goes down to the threshold, in the polar chart it goes to the center.\n\t\t */\n\t\tthis.closeSegment = function (path) {\n\t\t\tvar center = this.xAxis.center;\n\t\t\tpath.push(\n\t\t\t\t'L',\n\t\t\t\tcenter[0],\n\t\t\t\tcenter[1]\n\t\t\t);\t\t\t\n\t\t};\n\t\t\n\t\t// Instead of complicated logic to draw an area around the inner area in a stack,\n\t\t// just draw it behind\n\t\tthis.closedStacks = true;\n\t}\n}\nwrap(seriesTypes.area.prototype, 'init', initArea);\nwrap(seriesTypes.areaspline.prototype, 'init', initArea);\n\t\t\n\n/**\n * Overridden method for calculating a spline from one point to the next\n */\nwrap(seriesTypes.spline.prototype, 'getPointSpline', function (proceed, segment, point, i) {\n\t\n\tvar ret,\n\t\tsmoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc;\n\t\tdenom = smoothing + 1,\n\t\tplotX, \n\t\tplotY,\n\t\tlastPoint,\n\t\tnextPoint,\n\t\tlastX,\n\t\tlastY,\n\t\tnextX,\n\t\tnextY,\n\t\tleftContX,\n\t\tleftContY,\n\t\trightContX,\n\t\trightContY,\n\t\tdistanceLeftControlPoint,\n\t\tdistanceRightControlPoint,\n\t\tleftContAngle,\n\t\trightContAngle,\n\t\tjointAngle;\n\t\t\n\t\t\n\tif (this.chart.polar) {\n\t\t\n\t\tplotX = point.plotX;\n\t\tplotY = point.plotY;\n\t\tlastPoint = segment[i - 1];\n\t\tnextPoint = segment[i + 1];\n\t\t\t\n\t\t// Connect ends\n\t\tif (this.connectEnds) {\n\t\t\tif (!lastPoint) {\n\t\t\t\tlastPoint = segment[segment.length - 2]; // not the last but the second last, because the segment is already connected\n\t\t\t}\n\t\t\tif (!nextPoint) {\n\t\t\t\tnextPoint = segment[1];\n\t\t\t}\t\n\t\t}\n\n\t\t// find control points\n\t\tif (lastPoint && nextPoint) {\n\t\t\n\t\t\tlastX = lastPoint.plotX;\n\t\t\tlastY = lastPoint.plotY;\n\t\t\tnextX = nextPoint.plotX;\n\t\t\tnextY = nextPoint.plotY;\n\t\t\tleftContX = (smoothing * plotX + lastX) / denom;\n\t\t\tleftContY = (smoothing * plotY + lastY) / denom;\n\t\t\trightContX = (smoothing * plotX + nextX) / denom;\n\t\t\trightContY = (smoothing * plotY + nextY) / denom;\n\t\t\tdistanceLeftControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));\n\t\t\tdistanceRightControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));\n\t\t\tleftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);\n\t\t\trightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);\n\t\t\tjointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n\t\t\t\t\n\t\t\t\t\n\t\t\t// Ensure the right direction, jointAngle should be in the same quadrant as leftContAngle\n\t\t\tif (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n\t\t\t\tjointAngle -= Math.PI;\n\t\t\t}\n\t\t\t\n\t\t\t// Find the corrected control points for a spline straight through the point\n\t\t\tleftContX = plotX + Math.cos(jointAngle) * distanceLeftControlPoint;\n\t\t\tleftContY = plotY + Math.sin(jointAngle) * distanceLeftControlPoint;\n\t\t\trightContX = plotX + Math.cos(Math.PI + jointAngle) * distanceRightControlPoint;\n\t\t\trightContY = plotY + Math.sin(Math.PI + jointAngle) * distanceRightControlPoint;\n\t\t\t\n\t\t\t// Record for drawing in next point\n\t\t\tpoint.rightContX = rightContX;\n\t\t\tpoint.rightContY = rightContY;\n\n\t\t}\n\t\t\n\t\t\n\t\t// moveTo or lineTo\n\t\tif (!i) {\n\t\t\tret = ['M', plotX, plotY];\n\t\t} else { // curve from last point to this\n\t\t\tret = [\n\t\t\t\t'C',\n\t\t\t\tlastPoint.rightContX || lastPoint.plotX,\n\t\t\t\tlastPoint.rightContY || lastPoint.plotY,\n\t\t\t\tleftContX || plotX,\n\t\t\t\tleftContY || plotY,\n\t\t\t\tplotX,\n\t\t\t\tplotY\n\t\t\t];\n\t\t\tlastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n\t\t}\n\t\t\n\t\t\n\t} else {\n\t\tret = proceed.call(this, segment, point, i);\n\t}\n\treturn ret;\n});\n\n/**\n * Extend translate. The plotX and plotY values are computed as if the polar chart were a\n * cartesian plane, where plotX denotes the angle in radians and (yAxis.len - plotY) is the pixel distance from\n * center. \n */\nwrap(seriesProto, 'translate', function (proceed) {\n\t\t\n\t// Run uber method\n\tproceed.call(this);\n\t\n\t// Postprocess plot coordinates\n\tif (this.chart.polar && !this.preventPostTranslate) {\n\t\tvar points = this.points,\n\t\t\ti = points.length;\n\t\twhile (i--) {\n\t\t\t// Translate plotX, plotY from angle and radius to true plot coordinates\n\t\t\tthis.toXY(points[i]);\n\t\t}\n\t}\n});\n\n/** \n * Extend getSegmentPath to allow connecting ends across 0 to provide a closed circle in \n * line-like series.\n */\nwrap(seriesProto, 'getSegmentPath', function (proceed, segment) {\n\t\t\n\tvar points = this.points;\n\t\n\t// Connect the path\n\tif (this.chart.polar && this.options.connectEnds !== false && \n\t\t\tsegment[segment.length - 1] === points[points.length - 1] && points[0].y !== null) {\n\t\tthis.connectEnds = true; // re-used in splines\n\t\tsegment = [].concat(segment, [points[0]]);\n\t}\n\t\n\t// Run uber method\n\treturn proceed.call(this, segment);\n\t\n});\n\n\nfunction polarAnimate(proceed, init) {\n\tvar chart = this.chart,\n\t\tanimation = this.options.animation,\n\t\tgroup = this.group,\n\t\tmarkerGroup = this.markerGroup,\n\t\tcenter = this.xAxis.center,\n\t\tplotLeft = chart.plotLeft,\n\t\tplotTop = chart.plotTop,\n\t\tattribs;\n\n\t// Specific animation for polar charts\n\tif (chart.polar) {\n\t\t\n\t\t// Enable animation on polar charts only in SVG. In VML, the scaling is different, plus animation\n\t\t// would be so slow it would't matter.\n\t\tif (chart.renderer.isSVG) {\n\n\t\t\tif (animation === true) {\n\t\t\t\tanimation = {};\n\t\t\t}\n\t\n\t\t\t// Initialize the animation\n\t\t\tif (init) {\n\t\t\t\t\n\t\t\t\t// Scale down the group and place it in the center\n\t\t\t\tattribs = {\n\t\t\t\t\ttranslateX: center[0] + plotLeft,\n\t\t\t\t\ttranslateY: center[1] + plotTop,\n\t\t\t\t\tscaleX: 0.001, // #1499\n\t\t\t\t\tscaleY: 0.001\n\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tgroup.attr(attribs);\n\t\t\t\tif (markerGroup) {\n\t\t\t\t\tmarkerGroup.attrSetters = group.attrSetters;\n\t\t\t\t\tmarkerGroup.attr(attribs);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t// Run the animation\n\t\t\t} else {\n\t\t\t\tattribs = {\n\t\t\t\t\ttranslateX: plotLeft,\n\t\t\t\t\ttranslateY: plotTop,\n\t\t\t\t\tscaleX: 1,\n\t\t\t\t\tscaleY: 1\n\t\t\t\t};\n\t\t\t\tgroup.animate(attribs, animation);\n\t\t\t\tif (markerGroup) {\n\t\t\t\t\tmarkerGroup.animate(attribs, animation);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Delete this function to allow it only once\n\t\t\t\tthis.animate = null;\n\t\t\t}\n\t\t}\n\t\n\t// For non-polar charts, revert to the basic animation\n\t} else {\n\t\tproceed.call(this, init);\n\t} \n}\n\n// Define the animate method for both regular series and column series and their derivatives\nwrap(seriesProto, 'animate', polarAnimate);\nwrap(colProto, 'animate', polarAnimate);\n\n\n/**\n * Throw in a couple of properties to let setTooltipPoints know we're indexing the points\n * in degrees (0-360), not plot pixel width.\n */\nwrap(seriesProto, 'setTooltipPoints', function (proceed, renew) {\n\t\t\n\tif (this.chart.polar) {\n\t\textend(this.xAxis, {\n\t\t\ttooltipLen: 360 // degrees are the resolution unit of the tooltipPoints array\n\t\t});\t\n\t}\n\t\n\t// Run uber method\n\treturn proceed.call(this, renew);\n});\n\n\n/**\n * Extend the column prototype's translate method\n */\nwrap(colProto, 'translate', function (proceed) {\n\t\t\n\tvar xAxis = this.xAxis,\n\t\tlen = this.yAxis.len,\n\t\tcenter = xAxis.center,\n\t\tstartAngleRad = xAxis.startAngleRad,\n\t\trenderer = this.chart.renderer,\n\t\tstart,\n\t\tpoints,\n\t\tpoint,\n\t\ti;\n\t\n\tthis.preventPostTranslate = true;\n\t\n\t// Run uber method\n\tproceed.call(this);\n\t\n\t// Postprocess plot coordinates\n\tif (xAxis.isRadial) {\n\t\tpoints = this.points;\n\t\ti = points.length;\n\t\twhile (i--) {\n\t\t\tpoint = points[i];\n\t\t\tstart = point.barX + startAngleRad;\n\t\t\tpoint.shapeType = 'path';\n\t\t\tpoint.shapeArgs = {\n\t\t\t\td: renderer.symbols.arc(\n\t\t\t\t\tcenter[0],\n\t\t\t\t\tcenter[1],\n\t\t\t\t\tlen - point.plotY,\n\t\t\t\t\tnull, \n\t\t\t\t\t{\n\t\t\t\t\t\tstart: start,\n\t\t\t\t\t\tend: start + point.pointWidth,\n\t\t\t\t\t\tinnerR: len - pick(point.yBottom, len)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\tthis.toXY(point); // provide correct plotX, plotY for tooltip\n\t\t}\n\t}\n});\n\n\n/**\n * Align column data labels outside the columns. #1199.\n */\nwrap(colProto, 'alignDataLabel', function (proceed, point, dataLabel, options, alignTo, isNew) {\n\t\n\tif (this.chart.polar) {\n\t\tvar angle = point.rectPlotX / Math.PI * 180,\n\t\t\talign,\n\t\t\tverticalAlign;\n\t\t\n\t\t// Align nicely outside the perimeter of the columns\n\t\tif (options.align === null) {\n\t\t\tif (angle > 20 && angle < 160) {\n\t\t\t\talign = 'left'; // right hemisphere\n\t\t\t} else if (angle > 200 && angle < 340) {\n\t\t\t\talign = 'right'; // left hemisphere\n\t\t\t} else {\n\t\t\t\talign = 'center'; // top or bottom\n\t\t\t}\n\t\t\toptions.align = align;\n\t\t}\n\t\tif (options.verticalAlign === null) {\n\t\t\tif (angle < 45 || angle > 315) {\n\t\t\t\tverticalAlign = 'bottom'; // top part\n\t\t\t} else if (angle > 135 && angle < 225) {\n\t\t\t\tverticalAlign = 'top'; // bottom part\n\t\t\t} else {\n\t\t\t\tverticalAlign = 'middle'; // left or right\n\t\t\t}\n\t\t\toptions.verticalAlign = verticalAlign;\n\t\t}\n\t\t\n\t\tseriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n\t} else {\n\t\tproceed.call(this, point, dataLabel, options, alignTo, isNew);\n\t}\n\t\n});\n\n/**\n * Extend the mouse tracker to return the tooltip position index in terms of\n * degrees rather than pixels\n */\nwrap(pointerProto, 'getIndex', function (proceed, e) {\n\tvar ret,\n\t\tchart = this.chart,\n\t\tcenter,\n\t\tx,\n\t\ty;\n\t\n\tif (chart.polar) {\n\t\tcenter = chart.xAxis[0].center;\n\t\tx = e.chartX - center[0] - chart.plotLeft;\n\t\ty = e.chartY - center[1] - chart.plotTop;\n\t\t\n\t\tret = 180 - Math.round(Math.atan2(x, y) / Math.PI * 180);\n\t\n\t} else {\n\t\n\t\t// Run uber method\n\t\tret = proceed.call(this, e);\n\t}\n\treturn ret;\n});\n\n/**\n * Extend getCoordinates to prepare for polar axis values\n */\nwrap(pointerProto, 'getCoordinates', function (proceed, e) {\n\tvar chart = this.chart,\n\t\tret = {\n\t\t\txAxis: [],\n\t\t\tyAxis: []\n\t\t};\n\t\n\tif (chart.polar) {\t\n\n\t\teach(chart.axes, function (axis) {\n\t\t\tvar isXAxis = axis.isXAxis,\n\t\t\t\tcenter = axis.center,\n\t\t\t\tx = e.chartX - center[0] - chart.plotLeft,\n\t\t\t\ty = e.chartY - center[1] - chart.plotTop;\n\t\t\t\n\t\t\tret[isXAxis ? 'xAxis' : 'yAxis'].push({\n\t\t\t\taxis: axis,\n\t\t\t\tvalue: axis.translate(\n\t\t\t\t\tisXAxis ?\n\t\t\t\t\t\tMath.PI - Math.atan2(x, y) : // angle \n\t\t\t\t\t\tMath.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), // distance from center\n\t\t\t\t\ttrue\n\t\t\t\t)\n\t\t\t});\n\t\t});\n\t\t\n\t} else {\n\t\tret = proceed.call(this, e);\n\t}\n\t\n\treturn ret;\n});\n}(Highcharts));\n"]}