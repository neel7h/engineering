{"version":3,"file":"treemap-raphael.min.js","sources":["treemap-raphael.js"],"names":["define","Raphael","Treemap","draw","isArray","arr","constructor","Array","isFunction","func","Function","mergeProperties","originalproperties","newproperties","property","hasOwnProperty","drawTreemap","paper","boxes","labels","styles","index","i","j","newindex","label","length","slice","push","element","width","height","data","background","nodes","labelFormatter","boxDrawer","totalLabelLength","total","countLabels","fontSize","area","arearoot","Math","pow","min","style","coordinates","fill","font-size","averagelabelsize","boxFormatter","colors","color","stroke","drawbox","box","text","boxattr","labelattr","rgbobj","x1","y1","x2","y2","rect","getRGB","error","r","g","b","attr","getBBox","rotate","generate"],"mappings":"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","sourcesContent":["/*\n * Treemap Squared 0.5 - Treemap Charting library \n *\n * https://github.com/imranghory/treemap-squared/\n *\n * Copyright (c) 2012 Imran Ghory (imranghory@gmail.com)\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n */\n\n /* Hints for JSHint */ \n /*global Raphael, Treemap */\n\ndefine(['raphael', './treemap-squarify'], function(Raphael, Treemap){\n  (function() {\n    \"use strict\";\n    Treemap.draw = function(){ \n\n        // some utility functions \n        function isArray(arr) {\n            return arr && arr.constructor === Array; \n        }\n\n        function isFunction(func) {\n            return func && func.constructor === Function; \n        }\n\n        // mergeProperies - given two sets of associative arrays merge the,\n        //                  for clashes copy the new value over the original one\n        function mergeProperties(originalproperties, newproperties) {\n            var property;\n            for (property in newproperties) {\n                if (newproperties.hasOwnProperty(property)) {\n                    originalproperties[property] = newproperties[property];\n                }\n            }\n         return originalproperties;\n        }\n\n        // drawTreemap - recursively iterate through the nested array of boxes\n        //               and call the styles['draw'] method on them\n        function drawTreemap(paper, boxes, labels, styles, index) {\n            var i,j;\n            var newindex; // the index to the next box to draw\n            var label; // label of current box\n           \n            if(isArray(boxes[0][0])) {\n                for(i=0; i<boxes.length; i++) {\n                    newindex = index.slice();\n                    newindex.push(i);\n                    drawTreemap(paper, boxes[i],labels, styles, newindex);\n                }\n            } else {\n                for(i=0; i<boxes.length; i++) {\n                    newindex = index.slice();\n                    newindex.push(i);\n\n                    // figure out the matching label using the index \n                    label = labels;\n                    for(j=0; j<newindex.length; j++){\n                        label = label[newindex[j]];\n                    }\n                    \n                    // draw box & label\n                    styles.draw(boxes[i], label, newindex);\n                }\n            }\n        }\n\n\n        function draw(element, width, height, data, labels, styles) {\n            var paper, background, nodes, labelFormatter, boxDrawer;\n            styles = (typeof styles === \"undefined\") ? [] : styles;      \n\n            /* create some default style functions */\n\n            // This label formatter calculates a font-size based upon \n            // average label length and the size of the box the label is \n            // going into. The maximum font size is set to 20px.  \n            labelFormatter = function () {                 \n                var averagelabelsize = totalLabelLength(labels) / countLabels(labels); \n\n                // total length of labels (i.e [[\"Italy\"],[\"Spain\", \"Greece\"]] -> 16)\n                function totalLabelLength(arr) {\n                    var i, total = 0;\n                    if(isArray(arr[0])) {\n                        for(i=0; i<arr.length; i++) {\n                            total += totalLabelLength(arr[i]);\n                        }\n                    } else {\n                        for (i = 0; i<arr.length; i++){\n                           total += arr[i].length;  \n                        }\n                    }\n                    return total;\n                }\n\n                // count of labels (i.e [[\"Italy\"],[\"Spain\", \"Greece\"]] -> 3)\n                function countLabels(arr) {\n                    var i, total = 0;\n                    if(isArray(arr[0])) {\n                        for(i=0; i<arr.length; i++) {\n                            total += countLabels(arr[i]);\n                        }\n                    } else {\n                        for (i = 0; i<arr.length; i++){\n                           total += 1;  \n                        }\n                    }\n                    return total;\n                }\n\n                function fontSize(width, height) {\n                    // the font size should be proportional to the size of the box (and the value)\n                    // otherwise you can end up creating a visual distortion where two boxes of identical\n                    // size have different sized labels, and thus make it look as if the two boxes\n                    // represent diffferent sizes\n                    var area = width*height;\n                    var arearoot = Math.pow(area, 0.5);\n                    return Math.min( arearoot / (averagelabelsize), 20);\n                }\n\n                function style(coordinates, index) {\n                    return { \"fill\" : \"#FCFCFC\", \"font-size\": fontSize(coordinates[2] - coordinates[0], coordinates[3] - coordinates[1] )};   \n                }\n\n                return style;\n            }();\n\n            // default style for boxes\n            var boxFormatter = function (coordinates, index) {\n                var colors = [\"hsb(0,1,0.4)\", \"hsb(0.2,1,0.4)\", \"hsb(0.4,1,0.4)\", \"hsb(0.6,1,0.4)\", \"hsb(0.8,1,0.4)\"];  \n                var color = (index.length === 1) ? colors[2] : colors[(index[0] + 2) % 5];          \n                return  { \"stroke\": \"FEFEFE\", \"fill\" : color};\n            };\n\n\n            // default box & label drawing routine - in most cases this default one in combination with changing the styles\n            // will suffice. Only if you're doing something complex and want to rewrite how the treemap gets drawn\n            // would you replace this. \n            boxDrawer = function () { \n                function drawbox(coordinates, label, newindex) {\n                    var x1=coordinates[0], y1=coordinates[1], x2=coordinates[2], y2=coordinates[3];\n                    var box, text;\n                    var boxattr, labelattr;\n                    var rgbobj;\n\n                    // draw box \n                    box = paper.rect(x1, y1, x2 - x1, y2 - y1);\n                    \n                    boxattr = isFunction(styles.box) ? styles.box(coordinates, newindex) : styles.box;\n                    boxattr = mergeProperties(boxFormatter(coordinates, newindex), boxattr);\n\n                    // dirty hack to fix opacity support in non-webkit web browsers\n                    if (\"fill-opacity\" in boxattr) {\n                        rgbobj = Raphael.getRGB(boxattr.fill);\n                        if (!rgbobj.error) {\n                            boxattr.fill = \"rgba(\" + rgbobj.r + \",\" + rgbobj.g + \",\" + rgbobj.b + \",\" + boxattr['fill-opacity'] + \")\";\n                        } \n                    }\n\n                    box.attr(boxattr);\n\n                    // draw labels \n                    text = paper.text((x1 + x2) / 2, (y1 + y2) / 2, label);\n\n                    labelattr = isFunction(styles.label) ? styles.label(coordinates, newindex) : styles.label;\n                    labelattr = mergeProperties(labelFormatter(coordinates, newindex), labelattr);\n\n                    text.attr(labelattr);\n\n                    // if the label fits better sideways then rotate it\n                    if(text.getBBox().width > x2-x1 && text.getBBox().width <= y2-y1) {\n                        text.rotate(-90); \n                    }\n                    // TODO: add more sophisticated logic to shrink text if it overflows the box size   \n                }\n                return drawbox;\n            }();\n\n            styles.background = (typeof styles.background  === \"undefined\") ? {} : styles.background;\n            styles.label = (typeof styles.label  === \"undefined\") ? {} : styles.label;\n            styles.box = (typeof styles.box  === \"undefined\") ? {} : styles.box;\n            styles.draw = (typeof styles.draw  === \"undefined\") ? boxDrawer : styles.draw;\n\n            // create our canvas and style the background \n            paper = new Raphael(element, width, height);\n\n            background = paper.rect(0, 0, width, height);\n            background.attr(styles.background);\n\n            // generate our treemap from our data\n            nodes = Treemap.generate(data, width, height);\n\n            // draw the generated treemap\n            drawTreemap(paper, nodes, labels, styles, []);\n        }\n\n        return draw;\n    }();\n})();\n  return Treemap;\n});\n"]}