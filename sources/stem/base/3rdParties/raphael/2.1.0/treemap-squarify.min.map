{"version":3,"file":"treemap-squarify.min.js","sources":["treemap-squarify.js"],"names":["define","Treemap","generate","Container","xoffset","yoffset","width","height","this","shortestEdge","Math","min","getCoordinates","row","i","coordinates","subxoffset","subyoffset","areawidth","sumArray","areaheight","length","push","cutArea","area","newcontainer","newwidth","newheight","normalize","data","normalizeddata","sum","multiplier","treemapMultidimensional","mergedtreemap","mergeddata","results","isArray","sumMultidimensionalArray","treemapSingledimensional","rawtreemap","squarify","flattenTreemap","j","flattreemap","currentrow","container","stack","nextdatapoint","improvesRatio","slice","nextnode","newrow","currentratio","calculateRatio","newratio","apply","max","pow","arr","constructor","Array","total"],"mappings":"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","sourcesContent":["/*\n * treemap-squarify.js - open source implementation of squarified treemaps\n *\n * Treemap Squared 0.5 - Treemap Charting library \n *\n * https://github.com/imranghory/treemap-squared/\n *\n * Copyright (c) 2012 Imran Ghory (imranghory@gmail.com)\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n *\n *\n * Implementation of the squarify treemap algorithm described in:\n * \n * Bruls, Mark; Huizing, Kees; van Wijk, Jarke J. (2000), \"Squarified treemaps\" \n * in de Leeuw, W.; van Liere, R., Data Visualization 2000: \n * Proc. Joint Eurographics and IEEE TCVG Symp. on Visualization, Springer-Verlag, pp. 33â€“42.\n *\n * Paper is available online at: http://www.win.tue.nl/~vanwijk/stm.pdf\n *\n * The code in this file is completeley decoupled from the drawing code so it should be trivial\n * to port it to any other vector drawing library. Given an array of datapoints this library returns\n * an array of cartesian coordinates that represent the rectangles that make up the treemap.\n *\n * The library also supports multidimensional data (nested treemaps) and performs normalization on the data.\n * \n * See the README file for more details.\n */\ndefine(['raphael/main'], function(Raphael){\nvar Treemap = {};\n\n(function() {\n    \"use strict\";\n    Treemap.generate = function(){\n\n        function Container(xoffset, yoffset, width, height) {\n            this.xoffset = xoffset; // offset from the the top left hand corner\n            this.yoffset = yoffset; // ditto \n            this.height = height;\n            this.width = width;\n\n            this.shortestEdge = function () {\n                return Math.min(this.height, this.width);\n            };\n\n            // getCoordinates - for a row of boxes which we've placed \n            //                  return an array of their cartesian coordinates\n            this.getCoordinates = function (row) {\n                var coordinates = [];\n                var subxoffset = this.xoffset, subyoffset = this.yoffset; //our offset within the container\n                var areawidth = sumArray(row) / this.height;\n                var areaheight = sumArray(row) / this.width;\n                var i;\n\n                if (this.width >= this.height) {\n                    for (i = 0; i < row.length; i++) {\n                        coordinates.push([subxoffset, subyoffset, subxoffset + areawidth, subyoffset + row[i] / areawidth]);\n                        subyoffset = subyoffset + row[i] / areawidth;\n                    }\n                } else {\n                    for (i = 0; i < row.length; i++) {\n                        coordinates.push([subxoffset, subyoffset, subxoffset + row[i] / areaheight, subyoffset + areaheight]);\n                        subxoffset = subxoffset + row[i] / areaheight;\n                    }\n                }\n                return coordinates;\n            };\n\n            // cutArea - once we've placed some boxes into an row we then need to identify the remaining area, \n            //           this function takes the area of the boxes we've placed and calculates the location and\n            //           dimensions of the remaining space and returns a container box defined by the remaining area\n            this.cutArea = function (area) {\n                var newcontainer;\n\n                if (this.width >= this.height) {\n                    var areawidth = area / this.height;\n                    var newwidth = this.width - areawidth;\n                    newcontainer = new Container(this.xoffset + areawidth, this.yoffset, newwidth, this.height);\n                } else {\n                    var areaheight = area / this.width;\n                    var newheight = this.height - areaheight;\n                    newcontainer = new Container(this.xoffset, this.yoffset + areaheight, this.width, newheight);\n                }\n                return newcontainer;\n            };\n        }\n\n\n\n        // normalize - the Bruls algorithm assumes we're passing in areas that nicely fit into our \n        //             container box, this method takes our raw data and normalizes the data values into  \n        //             area values so that this assumption is valid.\n        function normalize(data, area) {\n            var normalizeddata = [];\n            var sum = sumArray(data);\n            var multiplier = area / sum;\n            var i;\n\n            for (i = 0; i < data.length; i++) {\n                normalizeddata[i] = data[i] * multiplier;\n            }\n            return normalizeddata;\n        }\n\n        // treemapMultidimensional - takes multidimensional data (aka [[23,11],[11,32]] - nested array)\n        //                           and recursively calls itself using treemapSingledimensional\n        //                           to create a patchwork of treemaps and merge them\n        function treemapMultidimensional(data, width, height, xoffset, yoffset) {\n            xoffset = (typeof xoffset === \"undefined\") ? 0 : xoffset;\n            yoffset = (typeof yoffset === \"undefined\") ? 0 : yoffset;\n            \n            var mergeddata = [];\n            var mergedtreemap;\n            var results = [];\n            var i;\n\n            if(isArray(data[0])) { // if we've got more dimensions of depth\n                for(i=0; i<data.length; i++) {\n                    mergeddata[i] = sumMultidimensionalArray(data[i]);\n                }\n                mergedtreemap = treemapSingledimensional(mergeddata, width, height, xoffset, yoffset);\n                \n                for(i=0; i<data.length; i++) {\n                    results.push(treemapMultidimensional(data[i], mergedtreemap[i][2] - mergedtreemap[i][0], mergedtreemap[i][3] - mergedtreemap[i][1], mergedtreemap[i][0], mergedtreemap[i][1]));\n                }\n            } else {\n                results = treemapSingledimensional(data,width,height, xoffset, yoffset);\n            }\n            return results;\n        }\n\n\n\n        // treemapSingledimensional - simple wrapper around squarify\n        function treemapSingledimensional(data, width, height, xoffset, yoffset) {\n            xoffset = (typeof xoffset === \"undefined\") ? 0 : xoffset;\n            yoffset = (typeof yoffset === \"undefined\") ? 0 : yoffset;\n\n            var rawtreemap = squarify(normalize(data, width * height), [], new Container(xoffset, yoffset, width, height), []);\n            return flattenTreemap(rawtreemap);\n        }\n\n        // flattenTreemap - squarify implementation returns an array of arrays of coordinates\n        //                  because we have a new array everytime we switch to building a new row\n        //                  this converts it into an array of coordinates.\n        function flattenTreemap(rawtreemap) {\n            var flattreemap = [];\n            var i, j;\n\n            for (i = 0; i < rawtreemap.length; i++) {\n                for (j = 0; j < rawtreemap[i].length; j++) {\n                    flattreemap.push(rawtreemap[i][j]);\n                }\n            }\n            return flattreemap;\n        }\n\n        // squarify  - as per the Bruls paper \n        //             plus coordinates stack and containers so we get \n        //             usable data out of it \n        function squarify(data, currentrow, container, stack) {\n            var length;\n            var nextdatapoint;\n            var newcontainer;\n\n            if (data.length === 0) {\n                stack.push(container.getCoordinates(currentrow));\n                return;\n            }\n\n            length = container.shortestEdge();\n            nextdatapoint = data[0];\n            \n            if (improvesRatio(currentrow, nextdatapoint, length)) {\n                currentrow.push(nextdatapoint);\n                squarify(data.slice(1), currentrow, container, stack);\n            } else {\n                newcontainer = container.cutArea(sumArray(currentrow), stack);\n                stack.push(container.getCoordinates(currentrow));\n                squarify(data, [], newcontainer, stack);\n            }\n            return stack;\n        }\n\n        // improveRatio - implements the worse calculation and comparision as given in Bruls\n        //                (note the error in the original paper; fixed here) \n        function improvesRatio(currentrow, nextnode, length) {\n            var newrow; \n\n            if (currentrow.length === 0) {\n                return true;\n            }\n            \n            newrow = currentrow.slice();\n            newrow.push(nextnode);\n            \n            var currentratio = calculateRatio(currentrow, length);\n            var newratio = calculateRatio(newrow, length);\n            \n            // the pseudocode in the Bruls paper has the direction of the comparison\n            // wrong, this is the correct one.\n            return currentratio >= newratio; \n        }\n\n        // calculateRatio - calculates the maximum width to height ratio of the\n        //                  boxes in this row\n        function calculateRatio(row, length) {\n            var min = Math.min.apply(Math, row);\n            var max = Math.max.apply(Math, row);\n            var sum = sumArray(row);\n            return Math.max(Math.pow(length, 2) * max / Math.pow(sum, 2), Math.pow(sum, 2) / (Math.pow(length, 2) * min));\n        }\n\n        // isArray - checks if arr is an array\n        function isArray(arr) {\n            return arr && arr.constructor === Array; \n        }\n\n        // sumArray - sums a single dimensional array \n        function sumArray(arr) {\n            var sum = 0;\n            var i;\n\n            for (i = 0; i < arr.length; i++) {\n                sum += arr[i];\n            }\n            return sum;\n        }\n\n        // sumMultidimensionalArray - sums the values in a nested array (aka [[0,1],[[2,3]]])\n        function sumMultidimensionalArray(arr) {\n            var i, total = 0;\n\n            if(isArray(arr[0])) {\n                for(i=0; i<arr.length; i++) {\n                    total += sumMultidimensionalArray(arr[i]);\n                }\n            } else {\n                total = sumArray(arr);\n            }\n            return total;\n        }\n\n        return treemapMultidimensional; \n    }();\n})();\n  return Treemap;\n});\n"]}