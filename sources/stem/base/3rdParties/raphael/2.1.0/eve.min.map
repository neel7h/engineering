{"version":3,"file":"eve.min.js","sources":["eve.js"],"names":["define","current_event","stop","version","has","separator","wildcard","fun","numsort","a","b","events","n","eve","name","scope","l","oldstop","args","Array","prototype","slice","call","arguments","listeners","z","indexed","queue","out","ce","i","ii","length","push","zIndex","sort","apply","item","items","k","j","jj","nes","names","split","e","es","concat","f","on","nt","subname","RegExp","test","unbind","key","splice","cur","funcs","once","f2","res","this","toString"],"mappings":"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","sourcesContent":["// ┌──────────────────────────────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.3.4 - JavaScript Events Library                                                │ \\\\\n// ├──────────────────────────────────────────────────────────────────────────────────────┤ \\\\\n// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)          │ \\\\\n// │ Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license. │ \\\\\n// └──────────────────────────────────────────────────────────────────────────────────────┘ \\\\\ndefine(function () {\n\n    var version = \"0.3.4\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n    /*\\\n     * eve\n     [ method ]\n     **\n     * Fires event with given `name`, given scope and other parameters.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n     **\n     = (object) array of returned values from the listeners\n     \\*/\n        eve = function (name, scope) {\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out.length ? out : null;\n        };\n    /*\\\n     * eve.listeners\n     [ method ]\n     **\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n     **\n     = (array) array of event handlers\n     \\*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eat)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catch)(1);\n     * This will ensure that `catch` function will be called before `eat`.\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n     \\*/\n    eve.on = function (name, f) {\n        var names = name.split(separator),\n            e = events;\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            e = e.n;\n            !e[names[i]] && (e[names[i]] = {n: {}});\n            e = e[names[i]];\n        }\n        e.f = e.f || [];\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n            return fun;\n        }\n        e.f.push(f);\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n     \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n     \\*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     \\*/\n    eve.unbind = function (name, f) {\n        var names = name.split(separator),\n            e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n     \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            var res = f.apply(this, arguments);\n            eve.unbind(name, f2);\n            return res;\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n     \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    return eve;\n});\n"]}