<?xml version="1.0" encoding="utf-8"?>
<root>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="associatedValueName">
    <english>Cyclomatic complexity</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="description">
    <english>Avoid Artifacts with High Cyclomatic Complexity (CC &gt; 20). Complex Artifacts are difficult to maintain. Keeping Artifacts small and simple ensures an good readability of the code.  The threshold level is a parameter that can be changed at will.</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="name">
    <english>Avoid Artifacts with High Cyclomatic Complexity (Python)</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="output">
    <english>Associated to each Python Artifact with violations, the Quality Rule provides:
- The Cyclomatic complexity</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="rationale">
    <english>The effort and time for diagnosis of deficiencies or causes of failures, or for identification of parts to be modified is directly related to the number of execution paths, i.e. the complexity of the control flow.
Analyzability declines with increasing Cyclomatic Complexity.
Each modification must be correct for all execution paths. Cyclomatic Complexity computes the number of the linearly independent paths, a lower bound of all execution paths ignoring multiple iterations.
Changeability declines with increasing Cyclomatic Complexity.
Complete testing requires coverage of all execution paths. Cyclomatic Complexity computes the number of the linearly independent paths, a lower bound of all execution paths ignoring multiple iterations.
Testability declines with increasing Cyclomatic Complexity.</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="remediation">
    <english>Review the design of the Artifact to reduce number of independent paths. E.g.: Reduce the number of conditional statements.</english>
  </metric>
  <metric id="1021000" type="quality-rule" originalName="Avoid Artifacts with High Cyclomatic Complexity (Python)" section="total">
    <english>Number of Python Artifacts</english>
  </metric>

  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python httplib syntax HTTPConnection, to do call to web service.</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="name">
    <english>Avoid using a web service with Python httplib HTTPConnection inside a loop</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server.
By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="reference">
    <english>CISQ OMG ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="sample">
    <english>&gt;&gt;&gt; from httplib import HTTPConnection
&gt;&gt;&gt; conn = HTTPConnection("www.python.org")
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;     conn.request("GET", url)</english>
  </metric>
  <metric id="1021002" type="quality-rule" originalName="Avoid using a web service with Python httplib HTTPConnection inside a loop" section="total">
    <english>Number of Python artifacts using httplib</english>
  </metric>

  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python requests syntax, to do call to web service.</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="name">
    <english>Avoid using a web service with Python requests inside a loop</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server. By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="reference">
    <english>CISQ OMG ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="sample">
    <english>&gt;&gt;&gt; import requests
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;      r = requests.get(url)</english>
  </metric>
  <metric id="1021004" type="quality-rule" originalName="Avoid using a web service with Python requests inside a loop" section="total">
    <english>Number of Python artifacts web service with Python requests</english>
  </metric>

  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python requests syntax, to do call to web service.</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="name">
    <english>Avoid using a web service with Python aiohttp ClientSession inside a loop</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server. By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="reference">
    <english>ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="sample">
    <english>&gt;&gt;&gt; import aiohttp
&gt;&gt;&gt; session = aiohttp.ClientSession()
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;     res = session.get(url)</english>
  </metric>
  <metric id="1021006" type="quality-rule" originalName="Avoid using a web service with Python aiohttp ClientSession inside a loop" section="total">
    <english>Number of Python artifacts web service with Python aiohttp</english>
  </metric>

  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python requests syntax, to do call to web service.</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="name">
    <english>Avoid using a web service with Python urllib.request inside a loop</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server. By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="reference">
    <english>CISQ OMG ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="sample">
    <english>&gt;&gt;&gt; import urllib.request
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;     res = urllib.request.urlopen(url)</english>
  </metric>
  <metric id="1021008" type="quality-rule" originalName="Avoid using a web service with Python urllib.request inside a loop" section="total">
    <english>Number of Python artifacts web service with Python urllib</english>
  </metric>

  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python requests syntax, to do call to web service.</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="name">
    <english>Avoid using a web service with Python urllib2 inside a loop</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server. By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="reference">
    <english>CISQ OMG ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="sample">
    <english>&gt;&gt;&gt; import urllib2
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;     res = urllib2.urlopen(url)</english>
  </metric>
  <metric id="1021010" type="quality-rule" originalName="Avoid using a web service with Python urllib2 inside a loop" section="total">
    <english>Number of Python artifacts web service with Python urllib2</english>
  </metric>

  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="description">
    <english>When designing web service to get/post/put data, you want to make sure that you minimize the number of calls between the client application and web service server. This rule will check the official Python requests syntax, to do call to web service.</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="name">
    <english>Avoid using a web service with Python httplib2 Http inside a loop</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="rationale">
    <english>When designing web service to get/put/post data, you want to make sure that you minimize the number of calls between the client application and web service server. By minimizing the number of calls, you improve application speed, reduce communications overhead (why send three request when you can do it by one), and reduce network traffic.</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="reference">
    <english>CISQ OMG ASCPEM-PRF-08</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="remediation">
    <english>Try to create a process queue that will manage all the requests with a limited number of concurrent requests. When a request callback has been managed a new request could be fired.</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="sample">
    <english>&gt;&gt;&gt; import httplib2
&gt;&gt;&gt; conn = httplib2.Http()
&gt;&gt;&gt; for url in urllist:
&gt;&gt;&gt;     res = conn.request(url,'GET')</english>
  </metric>
  <metric id="1021012" type="quality-rule" originalName="Avoid using a web service with Python httplib2 Http inside a loop" section="total">
    <english>Number of Python artifacts web service with Python httplib2</english>
  </metric>

  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="description">
    <english>Functions that are using yield and return with value (different from None) are very sensitive to the Python version. To avoid any technical complexity, we strongly suggest you to do not use these annotations together within functions in your code.</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="name">
    <english>Avoid using yield and return with value inside a function</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="rationale">
    <english>Mixing return with value and yield in the same function could lead to technical complexity. Based on the version used to run the Python script (2.x, 3.3, 3.4 for example), the results will not be the same.</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="remediation">
    <english>Try to avoid return with value statements within functions containing yield.</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="sample">
    <english>&gt;&gt;&gt; def generator1(n):
&gt;&gt;&gt;     for i in range(n):
&gt;&gt;&gt;         yield i
&gt;&gt;&gt;     return 0</english>
  </metric>
  <metric id="1021014" type="quality-rule" originalName="Avoid using yield and return with value inside a function" section="total">
    <english>Number of Python artifacts using yield</english>
  </metric>
  
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="description">
    <english>A violation is raised when detected the usage of MD5 and SHA1 algorithms to hash a password or a passphrase.</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="name">
    <english>Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="rationale">
    <english>The RSA's MD5 hashing algorithm is commonly used in different contexts such as checking data-integrity or simple indexing. However these algorithms should not be used for data encryption. The use of a non security-standard algorithm for hashing a password is dangerous because a determined attacker may be able to break the algorithm with well-known techniques and compromise whatever data has been protected.</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="remediation">
    <english>Avoid using MD5 and SHA1 hashes as input to cryptographic functions or to store passwords. Python offers the following hashing algorithms: SHA224, SHA256, SHA384, and SHA512. Make sure you choose the most appropriate one, depending on your use case, security requirements and runtime constraints.</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="remediationSample">
    <english>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; secure_hash = hashlib.sha512()
&gt;&gt;&gt; md5_hash.update(password)  # This hash is secure
&gt;&gt;&gt; md5_hash.digest()</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="sample">
    <english>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; md5_hash = hashlib.md5()
&gt;&gt;&gt; md5_hash.update(password)  # "This hash can be exploited"
&gt;&gt;&gt; md5_hash.digest()</english>
  </metric>
  <metric id="1021016" type="quality-rule" originalName="Avoid using MD5, SHA1 hashes to hash passwords or to encrypt data" section="total">
    <english>Number of Python artifacts using hashlib library</english>
  </metric>
  
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="description">
    <english>This metric reports all methods with at least one cath-all except block with an empty implementation. Working with exceptions is common to Python but sometimes using try/except blocks without doing anything when an exception happened is very dangerous.</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="name">
    <english>Avoid catch-all except blocks with empty handlers</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="rationale">
    <english>Exceptions are a mechanism to interrupt a program for signaling run-time anomalies in the code. In Python the common way for object type checking is to 'try' methods and properties. Thus well-defined exceptions are expected to appear and often the desired reaction is to silently ignore them.
        A catch-all except clause (one that captures all types of exceptions) when not properly handled ascribes this behaviour to every exception, included the unexpected. This practice should be avoided because it hinders debugging.</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="reference">
    <english>CISQ OMG ASCRM-RLB-01</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="remediation">
    <english>The exception must be handled correctly according to its type. If no exception type is declared or if a high-level cath-all exception type is used, the body of the exception block should execute specific code or inform if something wrong happened.</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="remediationSample">
    <english>&gt;&gt;&gt; # easy remediation
&gt;&gt;&gt; try:
&gt;&gt;&gt;     doSomething()
&gt;&gt;&gt; except:
&gt;&gt;&gt;     logging.debug("Someting happened")

&gt;&gt;&gt; # better remediation
&gt;&gt;&gt; try:
&gt;&gt;&gt;     doSomething()
&gt;&gt;&gt; except SomeException as e:
&gt;&gt;&gt;     logging.debug("Something happened:" + e.error)
&gt;&gt;&gt; except:
&gt;&gt;&gt;     logging.debug("Something unexpected happened ...")</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="sample">
    <english>&gt;&gt;&gt; try:
&gt;&gt;&gt;     doSomething()
&gt;&gt;&gt; except:          # no exception type declared
&gt;&gt;&gt;     pass         # empty handler</english>
  </metric>
  <metric id="1021018" type="quality-rule" originalName="Avoid catch-all except blocks with empty handlers" section="total">
    <english>Number of Python artifacts handling exceptions</english>
  </metric>
  
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="description">
    <english>Most of the time the import statements should be as specific as possible and you should only import what is needed. When from module import * is used, you are implicitly loading all locals of the imported module into and over the importing module. This has two disadvantages: first, you might unintentionally overload already imported objects. Second, it becomes difficult to detect undefined names in the program that imported the module.</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="name">
    <english>Avoid using wildcard (*) imports</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="rationale">
    <english>Software that does not follow the principles of reuse requires more maintenance effort in order to propagate changes to all instances of duplicated code</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="remediation">
    <english>Avoid using wildcard (*) imports. Either import the full module. A direct import would bind to the same name as that of another object. Second way is to make the import statement more specific.</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="remediationSample">
    <english>&gt;&gt;&gt; from math import floor
&gt;&gt;&gt; from numpy import floor as np_floor
&gt;&gt;&gt; values = array([2.3, 8.7])
&gt;&gt;&gt; np_floor(values)</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="sample">
    <english>&gt;&gt;&gt; from math import *
&gt;&gt;&gt; from numpy import *</english>
  </metric>
  <metric id="1021020" type="quality-rule" originalName="Avoid using wildcard (*) imports" section="total">
    <english>Number of Python artifacts importing modules</english>
  </metric>

  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="description">
    <english>Inheritance in object-oriented programming allows code reuse between hierarchically related classes. In Python by default the subclass inherits all of the methods including the __init__ method which is usually used for instance member initialization. However the subclass can replace any particular implementation that has inherited. To avoid accidental access to uninitialized instance members we strongly suggest you to initialize ancestor classes in the overriden __init__ method or to reconsider refactoring the code so that no inheritance is needed.</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="name">
    <english>'Initialize ancestors when overriding __init__'</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="rationale">
    <english>Accessing uninitialized variables is a typical source of errors and unexpected behaviour. Overriding the __init__ method of an ancestor class without initializing it can leave unitialized instance members.</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="remediation">
    <english>Initialize ancestors when overriding __init__ using consistently non-super methods or super() if their ancestors do.</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="remediationSample">
    <english>&gt;&gt;&gt; # approach (1)
&gt;&gt;&gt; class B(A):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         super().__init__()        # in Python2: super(B, self).__init__()
&gt;&gt;&gt;         self.y = 2
&gt;&gt;&gt;
&gt;&gt;&gt; # approach (2)
&gt;&gt;&gt; class B(A):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         A.__init__()
&gt;&gt;&gt;         self.y = 2</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="sample">
    <english>&gt;&gt;&gt; class A:
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.x = 3
&gt;&gt;&gt;         self.y = 14
&gt;&gt;&gt;
&gt;&gt;&gt; class B(A):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.y = 2</english>
  </metric>
  <metric id="1021022" type="quality-rule" originalName="'Initialize ancestors when overriding __init__'" section="total">
    <english>Number of Python artifacts initializing instance members</english>
  </metric>
  
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="description">
    <english>Reports all methods that contain an abrupt in a finally block. An abrupt completion of a statement or block occurs when it throws an exception, executes a break or continues to an enclosing statement, or executes a return from the method.</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="name">
    <english>Avoid return statement in finally block</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="rationale">
    <english>Care must be taken if completion of a try-catch block occurs as a result of executing a return. If a finally block also returns a value, then that return supersedes any previous return in the try-catch block. Also, if an exception was thrown in the try or catch blocks that was not caught, then execution of a return in the finally block prevents the exception from being thrown to the caller (because it is not possible for the caller to simultaneously evaluate the return and catch the exception). This is also valid for break or continue instructions.</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="reference">
    <english>CISQ OMG ASCMM-MNT-01</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="remediation">
    <english>Avoid using finally statement in return block. If used, it will swallow the exception raised but not handled in above try except block.</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="remediationSample">
    <english>&gt;&gt;&gt; def experiment():
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         x = 2/0
&gt;&gt;&gt;     except:
&gt;&gt;&gt;         logging.debug("Not Possible")
&gt;&gt;&gt;     finally:
&gt;&gt;&gt;         logging.debug("Division")
&gt;&gt;&gt;         clean_up_code()    #Return should not be used inside finally</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="sample">
    <english>&gt;&gt;&gt; def experiment():
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         x = 2/0
&gt;&gt;&gt;     except:
&gt;&gt;&gt;         logging.debug("Not possible")
&gt;&gt;&gt;     finally:
&gt;&gt;&gt;         logging.debug("Division")
&gt;&gt;&gt;         return</english>
  </metric>
  <metric id="1021024" type="quality-rule" originalName="Avoid return statement in finally block" section="total">
    <english>Number of Python artifacts handling exceptions</english>
  </metric>

  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="description">
    <english>Reports all Python artifacts that don't guarantee unequivocal file closing. This requires correct handling of potential exceptions arising from file manipulation.
The preferred way (from Python 2.5) is opening files using the with statement. Otherwise file manipulation has to be performed inside try-except blocks and file closing has to be assured in the finally block.</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="name">
    <english>Avoid leaving open file resources (Python)</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="rationale">
    <english>When a file is opened by Python, resources are allocated until the file is closed. Thus it is important to ensure the file is closed as soon as the file manipulation is done by handling correctly potential exceptions. Delegating file closing to the underlying interpreter/compiler can have a negative impact on code portability and can result in unexpected behavior.</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="reference">
    <english>This rule is compliant with OMG CISQ ASCPEM-PRF-15, ASCRM-CWE-772 recommendations.</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="remediation">
    <english>Use the with statement to open a file, otherwise explicitly close opened files while correctly handling exceptions arising from file manipulation.</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="remediationSample">
    <english>&gt;&gt;&gt; f = open("hello.txt", 'w')
&gt;&gt;&gt; try:
&gt;&gt;&gt;     f.write("world")
&gt;&gt;&gt; finally:
&gt;&gt;&gt;     f.close()

# or even better
&gt;&gt;&gt; with open("hello.txt", 'w') as f:
&gt;&gt;&gt;     f.write("world")</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="sample">
    <english>&gt;&gt;&gt; f = open("hello.txt",'w')
&gt;&gt;&gt; f.write("world")
&gt;&gt;&gt; f.close()</english>
  </metric>
  <metric id="1021026" type="quality-rule" originalName="Avoid leaving open file resources (Python)" section="total">
    <english>Number of Python artifacts opening file resources</english>
  </metric>
  
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="description">
    <english>In a try and catch/finally statement, finally blocks should contain code to handle the thrown exception or release resources.</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="name">
    <english>Avoid empty finally block (Python)</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="rationale">
    <english>Finally blocks must be used to execute the code that is needed after either the try and/or the catch block have been executed. It is usually the place to code the release of resources used in the try block. As such, an empty finally block is most probably the sign of potential "resource leaks" that will jeopardize the application's stability.</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="reference">
    <english>CISQ OMG ASCRM-RLB-01</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="remediation">
    <english>Avoid empty finally blocks. Finally block should contain code to release resource.</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="remediationSample">
    <english>&gt;&gt;&gt; def experiment():
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         x = 2/0
&gt;&gt;&gt;     except ZeroDivisionError as e:
&gt;&gt;&gt;         logging.debug("Division by 0 not possible")
&gt;&gt;&gt;     finally:
&gt;&gt;&gt;         logging.debug("Quotient")</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="sample">
    <english>&gt;&gt;&gt; def experiment():
&gt;&gt;&gt;     try:
&gt;&gt;&gt;         x = 2/0
&gt;&gt;&gt;     except ZeroDivisionError as e:
&gt;&gt;&gt;         logging.debug("Division by 0 not possible")
&gt;&gt;&gt;     finally:
&gt;&gt;&gt;         pass</english>
  </metric>
  <metric id="1021028" type="quality-rule" originalName="Avoid empty finally block (Python)" section="total">
    <english>Number of Python artifacts handling exceptions</english>
  </metric>
  
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="description">
    <english>Reports all Python artifacts harcoding network resources that do not partain to configuration, installation, or test files.</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="name">
    <english>Avoid hardcoded network resource names (Python)</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="rationale">
    <english>Built-in remote addresses cause problems when the target is moved. Avoid hardcoded network resources (e.g., IP addresses, URLs, absolute file paths, etc.) to assure robustness and portability.</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="remediation">
    <english>Utilize indirect access to network resources using underlaying operating system calls and relative paths. In case hardcoding is necessary, isolating hardcoded data to installation scripts or configuration files can limit its potential negative impact.</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="remediationSample">
    <english>&gt;&gt;&gt; # "server_address" is uploaded from somewhere else
&gt;&gt;&gt; url = "http://%s:%d/" % server_address</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="sample">
    <english>&gt;&gt;&gt; url = "http://0.0.0.0:8080/'</english>
  </metric>
  <metric id="1021030" type="quality-rule" originalName="Avoid hardcoded network resource names (Python)" section="total">
    <english>Number of Python artifacts opening file resources</english>
  </metric>
  
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="description">
    <english>In Python, to avoid connection to unsecured source, developer has to ensure that all HTTP communication are encrypted. Avoid man-in-the-middle attacks by validating certificates on HTTPS connections to the server.</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="name">
    <english>Avoid disabling certificate check when requesting secured urls</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="rationale">
    <english>Ensure the developer will work with a list of trusted source. Thanks to Strict-Transport-Security header you will enforces secure (HTTP over SSL/TLS) connections to the server.</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="remediation">
    <english>Ensure you have enabled secure https connection when creating your connection.</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="remediationSample">
    <english>&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.get(url = "https://www.openstack.org/", verify = CONF.ca_file) #Certificate check will be performed using file
&gt;&gt;&gt; requests.get(url = "https://myserver.com") # Certificate check will be perfomed. Default value of verify "True" will be processed</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="sample">
    <english>&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.get(url = "https://www.openstack.org/",verify = False)</english>
  </metric>
  <metric id="1021032" type="quality-rule" originalName="Avoid disabling certificate check when requesting secured urls" section="total">
    <english>Number of Python artifacts using requests</english>
  </metric>

  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="description">
    <english>Reports all Python __init__ methods that override the __init__() method of the parent Exception class with inconsistent number of passed arguments.</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="name">
    <english>Avoid inconsistent initialization when deriving a new exception</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="rationale">
    <english>Python Exceptions accept all arguments passed to them being stored in the .args attribute as a tuple. Various libraries and parts of Python rely on this behaviour. To prevent source of errors and unexpected behaviour, avoid inconsistent initialization when subclassing a new exception by passing the same number of arguments to the parent __init__ call.</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="reference">
    <english>D. Beazley and B.K. Jones, Python Cookbook, 3rd Ed. (O'Reilly Media, Sebastopol, CA, May 2013), p. 579</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="remediation">
    <english>Initialize parent exception class with the same number of parameters.</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="remediationSample">
    <english>&gt;&gt;&gt; class CustomError(Exception):
&gt;&gt;&gt;     def __init__(self, message, status):
&gt;&gt;&gt;     self.message = message
&gt;&gt;&gt;     self.status = status
&gt;&gt;&gt;     # parent exception class is initialized with same number of parameters
&gt;&gt;&gt;     super().__init__(message, status)</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="sample">
    <english>&gt;&gt;&gt; class CustomError(Exception):
&gt;&gt;&gt;     def __init__(self, message, status):
&gt;&gt;&gt;     self.message = message
&gt;&gt;&gt;     self.status = status</english>
  </metric>
  <metric id="1021034" type="quality-rule" originalName="Avoid inconsistent initialization when deriving a new exception" section="total">
    <english>Number of Python __init__ methods</english>
  </metric>
  
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="description">
    <english>The eval statement is used to run Python stored in literal strings as code. In almost all cases, it should not be necessary to use it. Because it allows arbitrary code to be run, it also represents a security problem.</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="name">
    <english>Avoid using eval (Python)</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="rationale">
    <english>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. "eval").</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="remediation">
    <english>If possible, refactor your code so that it does not need to use eval() at all.</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="remediationSample">
    <english>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.mkdir("C://New_Folder_1")</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="sample">
    <english>&gt;&gt;&gt; import os
&gt;&gt;&gt; stat = 'os.mkdir("C://New_Folder_1")'
&gt;&gt;&gt; eval(stat)</english>
  </metric>
  <metric id="1021036" type="quality-rule" originalName="Avoid using eval (Python)" section="total">
    <english>Number of Python artifacts</english>
  </metric>

  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="description">
    <english>The exec statement is used to run Python stored in literal strings as code. In almost all cases, it should not be necessary to use it. Because it allows arbitrary code to be run, it also represents a security problem.</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="name">
    <english>Avoid using exec (Python)</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="rationale">
    <english>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. "exec").</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="reference">
    <english>http://cwe.mitre.org/data/definitions/95.html https://www.owasp.org/index.php/Top_10_2013-A1-Injection</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="remediation">
    <english>In most scenarios, you can easily refactor the code to avoid the use of exec.</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="remediationSample">
    <english>&gt;&gt;&gt; def print_hello_world()
&gt;&gt;&gt;     logging.debug("Hello, World!")
&gt;&gt;&gt; print_hello_world()</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="sample">
    <english>&gt;&gt;&gt; s = "logging.debug(\"Hello, World!\")"
&gt;&gt;&gt; exec s</english>
  </metric>
  <metric id="1021038" type="quality-rule" originalName="Avoid using exec (Python)" section="total">
    <english>Number of Python artifacts</english>
  </metric>

  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="description">
    <english>Python is a case-sensitive language which allows reutilization of identifier names for different types by simple capitalization changes. A typical example would be using capitalized class names and the corresponding lowercase names for their instances. However defining attributes (methods and fields) in a class that only differ by capitalization can lead to confusion and to unexpected behaviour when used with case-insensitive interfaces.</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="name">
    <english>Avoid instance attributes only differing by capitalization</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="rationale">
    <english>Differentiating instance attributes by only changing name capitalization is a poor naming practice and source of confusion for future users of the class.</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="remediation">
    <english>Rename the attributes in a more discernible way.</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="remediationSample">
    <english>&gt;&gt;&gt; class Transmission:
&gt;&gt;&gt;     def __init__(self, callObject):
&gt;&gt;&gt;         self.callObject = callObject
&gt;&gt;&gt;
&gt;&gt;&gt;     def call(self):
&gt;&gt;&gt;         self.callObject.call()</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="sample">
    <english>&gt;&gt;&gt; class Transmission:
&gt;&gt;&gt;     def __init__(self, callObject):
&gt;&gt;&gt;         self.Call = callObject
&gt;&gt;&gt;
&gt;&gt;&gt;     def call(self):
&gt;&gt;&gt;         self.Call.call()</english>
  </metric>
  <metric id="1021040" type="quality-rule" originalName="Avoid instance attributes only differing by capitalization" section="total">
    <english>Number of Python classes</english>
  </metric>
  
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="description">
    <english>This rule identifies variable assignments and function calls and interfaces that include a hardcoded password. This identification is based on password-related semantics.</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="name">
    <english>Avoid hardcoded passwords (Python)</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="rationale">
    <english>Hardcoded passwords in source code should be avoided because they can potentially be retrieved through code inspection and inverse engineering by attackers. Such an attack is difficult to be discovered, and eventually the problem can only be solved at software level thus compromising the usability of the application in the meantime.</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="reference">
    <english>https://cwe.mitre.org/data/definitions/259.html</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="remediation">
    <english>A non-secure starting patch would be to apply obfuscation techniques to the hardcoded password to prevent reverse-engineering of the generated Python (byte)code. This could be done by hashing the password or constructing the password string in many different places by non-trivial methods. Sensitive data such as passwords should be in principle encrypted and saved in separate files or in a database with restricted user access.
Finally one should consider removing backdoors and delegate the password ownership to the end-user.</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="sample">
    <english>&gt;&gt;&gt; set_password(user = "John", password = "WinterIsComing")</english>
  </metric>
  <metric id="1021042" type="quality-rule" originalName="Avoid hardcoded passwords (Python)" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="description">
    <english>This rule identifies potential risky string interpolations used to parameterize SQL queries.</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="name">
    <english>Avoid Python string interpolations to prevent SQL injections</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="rationale">
    <english>To avoid the creation of Injection flaws, the Open Web Application Security Project (OWASP) recommends to check "Injection flaws, such as SQL, OS, and LDAP injection occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s hostile data can trick the interpreter into executing unintended commands or accessing data without proper authorization."

The Common Weakness Enumeration defines Improper Neutralization of Special Elements used in an SQL Command ( CWE-89 ) as follows:

"Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands.
SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes."</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="remediation">
    <english>Common database libraries handling SQL code provide specific API to perform parameterized SQL queries. Use them to assure sanitized SQL queries.</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="remediationSample">
    <english>&gt;&gt;&gt; from flask.ext.sqlalchemy import SQLAlchemy
&gt;&gt;&gt; db = SQLAlchemy(app)
&gt;&gt;&gt; db.execute('insert into entries (title, text) values (?, ?)', [request.form['title'], request.form['text']])</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="sample">
    <english>&gt;&gt;&gt; from flask.ext.sqlalchemy import SQLAlchemy
&gt;&gt;&gt; db = SQLAlchemy(app)
&gt;&gt;&gt; db.execute("insert into entries (title, text) values ('{0}', '{1}')".format(request.form['title'], request.form['text']))</english>
  </metric>
  <metric id="1021044" type="quality-rule" originalName="Avoid Python string interpolations to prevent SQL injections" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="description">
    <english>This rule will raise a violation in Python artifacts containing expressions using the "not ... is" syntax.</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="name">
    <english>Avoid Not ... Is</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="rationale">
    <english>Since Python version 2.3 the "is not" keyword pair is an operator in its own right. The expression "x is not y" is equivalent to "not (x is y)" and because of operator precedence rules it can be also expressed without parenthesis as "not x is y". The latter form can be a source of unexpected logical behavior as it appears reversed with respect to the natural English construction "is not". Thus it is recommended to use the "x is not y" form.</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="remediation">
    <english>Highlight operator precedence by adding parenthesis or even better rewrite the identity comparison with the "is not" operator.</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="remediationSample">
    <english>&gt;&gt;&gt; if not (x is y):
&gt;&gt;&gt;     ...
&gt;&gt;&gt;
&gt;&gt;&gt; # Or preferably
&gt;&gt;&gt;
&gt;&gt;&gt; if x is not y:
&gt;&gt;&gt;     ...</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="sample">
    <english>&gt;&gt;&gt; if not x is y:
&gt;&gt;&gt;     ...</english>
  </metric>
  <metric id="1021046" type="quality-rule" originalName="Avoid Not ... Is" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="description">
    <english>This rule raises a violation when loading sensitive data using the OpenStack framework without the protection flag.</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="name">
    <english>Protect sensitive data in config files from disclosure</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="rationale">
    <english>Frameworks offer many flags in their APIs to properly handle sensitive data. Using them is particularly important to avoid accidental exposition of loaded passwords through accidental debug logging.</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="remediation">
    <english>Add the ‘secret=True’ flag to the ‘cfg.StrOpt()’ function when registering the oslo configuration.</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="remediationSample">
    <english>cfg.StrOpt('myPassword123',
                 help='pss',
                 secret=True) # sanitize and protection</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="sample">
    <english>cfg.StrOpt('myPassword123',
                 help='pss')</english>
  </metric>
  <metric id="1021048" type="quality-rule" originalName="Protect sensitive data in config files from disclosure" section="total">
    <english>Number of Python artifacts</english>
  </metric>

  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="description">
    <english>Cross-site scripting attacks often access cookies in an attempt to steal session identifiers or authentication tokens. This is why all major browsers support the secure cookie property that prevents client-side scripts from accessing the cookie. The Secure attribute for sensitive cookies in HTTPS sessions is not set, which could cause the user agent to send those cookies in plaintext over an HTTP session.</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="name">
    <english>Avoid using unsecured cookie (Python)</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="rationale">
    <english>The Secure attribute for sensitive cookies in HTTPS sessions is not set, which could cause the user agent to send those cookies in plaintext over an HTTP session.</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="remediation">
    <english>Always setting secure option when creating a cookie or set the environment variable CSRF_COOKIE_SECURE to 'True' in the Django settings file.</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="remediationSample">
    <english>def view_method(request):
  res = HttpResponse()
  res.set_cookie("emailCookie", email, secure=True)
  return res
...
or alternatively keep the formulation and modify the settings file (such as settings.py) with:
CSRF_COOKIE_SECURE = True</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="sample">
    <english>from django.http.response import HttpResponse
...
def view_method(request):
  res = HttpResponse()
  res.set_cookie("emailCookie", email)
  return res
...</english>
  </metric>
  <metric id="1021050" type="quality-rule" originalName="Avoid using unsecured cookie (Python)" section="total">
    <english>Number of Python functions</english>
  </metric>

  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="description">
    <english>A violation is raised within a Python module when code lines longer than 99 characters are found in the source code, or when comment lines exceed 72 characters. Inline comments are considered part of a code line. Docstrings are not evaluated by this rule but they are analyzed by a separated quality rule.</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="name">
    <english>Avoid too long lines</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="rationale">
    <english>It is common among software projects to agree on a maximum length for code lines. The main reason behind this restriction is to improve readability, especially when comparing line by line different versions of the same file. Widespread presence of long lines can also indicate the need of code refactoring. Python offers different solutions to wrap long statements that help enhancing the visual structure of the code.</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="reference">
    <english>PEP-8</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="remediation">
    <english>The first step is to wrap long statements trying to visually enhance at the same time its inner structure. As recommended in PEP-8: "The preferred way of wrapping long lines is by using Python’s implied line continuation inside parentheses, brackets and braces. Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation." Nowadays IDEs can be configurated to automatically signal too long code lines and visualize length margins. When systematically finding the need to have long lines in a module, it should be considered code refactoring, in particular when highly nested code blocks, too large number of function parameters, or too long object names are found.</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="remediationSample">
    <english>castle = MakeBigCastle(rocks = rocks,
                                           wood = wood,
                                           water = water)</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="sample">
    <english>castle = MakeBigCastle(rocks = rocks_from_the_mountain, wood = wood_from_the_forest, water = water_from_the_well)</english>
  </metric>
  <metric id="1021052" type="quality-rule" originalName="Avoid too long lines" section="total">
    <english>Number of Python artifacts</english>
  </metric>

  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="description">
    <english>A violation is raised within a python artifact (module, class or function/method) when, in their respective docstrings, lines longer than 72 characters are found. This rule is compliant with the PEP-8 recommendation.</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="name">
    <english>Avoid long docstring lines</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="rationale">
    <english>In Python any first statement being a standalone string expression (within a module, class, function or method) is interpreted as a documentation string (or docstring). This normalized format for documentation is leveraged by many tools in the Python ecosystem. Long docstring lines can have a negative impact on API readability and thus slow down its interpretation and eventual utilization.</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="remediation">
    <english>Wrap docstrings following PEP-8 conventions.</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="remediationSample">
    <english>def my_function():
  """
  This is a multiline
  docstring
  """</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="sample">
    <english>def my_function():
  """This is a too ........... long ................. docstring ......................."""</english>
  </metric>
  <metric id="1021054" type="quality-rule" originalName="Avoid long docstring lines" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="description">
    <english>A violation is raised when detected missing whitespaces in comma-separated object lists. This does not apply to trailing commas in multiline expressions or single-element tuples. This rule is compliant with the PEP-8 recommendation.</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="name">
    <english>Missing whitespace after comma</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="rationale">
    <english>Readability of code is one of the most important factors behind the design of the Python language. Thus it is common to find Python syntax constructs and conventions that closely follow English grammar and rules. In this spirit, a sequence of comma-separated objects should include a single whitespace after each comma.</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="remediation">
    <english>Add a single whitespace after each comma-separated object sequences (lists, dictionaries, function arguments etc.). Most editors can be configurated to automatically introduce missing whitespaces.</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="remediationSample">
    <english>parameters = [var1, var2, var3]</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="sample">
    <english>parameters = [var1,var2,var3]</english>
  </metric>
  <metric id="1021056" type="quality-rule" originalName="Missing whitespace after comma" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  
 <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="description">
    <english>A violation is raised when detected superfluous parentheses in expressions.</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="name">
    <english>Avoid superfluous parenthesis</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="rationale">
    <english>Clever use of optional parentheses in expressions involving few operators or long lines can dramatically enhance the readability of the code. On the contrary, when a superfluous parenthesis is unintentionally introduced (perhaps influenced by other language syntaxes) it contributes to visual clutter.</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="reference">
    <english>PEP-8</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="remediation">
    <english>Remove the superfluous parenthesis or leverage it to construct multiline expressions.</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="remediationSample">
    <english># example 1
if value == 1: 
   return value

# example 2
while (condition1 and
            condition2 and
            condition3):
    do_something()</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="sample">
    <english># example 1 
if (value == 1): 
    return value

# example 2 
while (condition1 and condition2 and condition3):
    do_something()</english>
  </metric>
  <metric id="1021058" type="quality-rule" originalName="Avoid superfluous parenthesis" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="description">
    <english>A violation is raised when detected trailing whitespace in code lines.</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="name">
    <english>Avoid trailing whitespace</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="rationale">
    <english>Trailing whitespace left in source code is generally inocuous. There is a single exception in Python: if the line continuation backslash marker is followed by an unintentional space and a newline, then it is not interpreted as a line continuation. Besides this syntactic issue, non-meaningful differences in files might get registered because of trailing whitespace addition or removal. It is thus recommended to avoid trailing whitespaces in code.</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="reference">
    <english>PEP-8</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="remediation">
    <english>Most editors can be configurated to automatically remove trailing whitespace from code.</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021060" type="quality-rule" originalName="Avoid trailing whitespace" section="total">
    <english>Number of Python artifacts</english>
  </metric>

  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="description">
    <english>A violation is raised when a variable names departure from the PEP-8 recommendations, i.e., when using capitalized names (except for variables detected to be assigned to a class) or "camelCased" naming. Then single character variable names 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) will also raise a violation.</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="name">
    <english>Respect variable naming conventions</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="rationale">
    <english>Consistency in object naming conventions improves the reading comprehension of new contributors to the code base and thus increases productivity. Naming conventions reported in the official Python style guide known as PEP-8 is recognized as a standard accross the industry and the open source community.</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="remediation">
    <english>Rename the variable (and updated all references to it) following the PEP-8 recommendations in https://pep8.org/#prescriptive-naming-conventions.</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="remediationSample">
    <english># example 1
length = len(values)

# example 2 
good_name = values[red]    # snake_cased variable name</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="sample">
    <english># example 1 
l = len(values)

# example 2
badName = values[red]</english>
  </metric>
  <metric id="1021062" type="quality-rule" originalName="Respect variable naming conventions" section="total">
    <english>Number of Python artifacts</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="description">
    <english>A violation is raised when a variable names departure from the PEP-8 recommendations, i.e., when using capitalized names (except for variables detected to be assigned to a class) or "camelCased" naming. Then single character variable names 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) will also raise a violation.</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="name">
    <english>Respect function naming conventions</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="rationale">
    <english>This rule will raise a violation when function names departure from the PEP-8 recommendations, i.e., when the recommended use of "snake_cased" naming convention is not used. However, the use of intercalated acronyms is allowed.</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="remediation">
    <english>Rename the function (and update all references to it) following the PEP-8 recommendations in https://pep8.org/#function-names.</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="remediationSample">
    <english>def good_name():
    pass</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="sample">
    <english>def badName():
    pass</english>
  </metric>
  <metric id="1021064" type="quality-rule" originalName="Respect function naming conventions" section="total">
    <english>Number of Python Methods</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="description">
    <english>This rule will raise a violation when class names departure from the PEP-8 recommendations, i.e., when the recommended use of capitalized "CamelCased" naming convention is not used. Exceptions to these rules are found in classes whose instances are expected to be called as functions (i.e. when the "__call__" method is defined). Use of acronymns in class naming is also acceptable.</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="name">
    <english>Respect class naming conventions</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="rationale">
    <english>Consistency in object naming conventions improves the reading comprehension of new contributors to the code base and thus increases productivity. Naming conventions reported in the official Python style guide known as PEP-8 is recognized as a standard accross the industry and the open source community.</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="remediation">
    <english>Rename the class (and update all references to it) following the PEP-8 recommendations in https://pep8.org/#class-names.</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="remediationSample">
    <english>class GoodName:
    pass</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="sample">
    <english>class bad_name:
    pass</english>
  </metric>
  <metric id="1021066" type="quality-rule" originalName="Respect class naming conventions" section="total">
    <english>Number of Python Classes</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="description">
    <english>This rule will raise a violation when a variable is explicitly declared as global using the "global" keyword. This rule doesn't apply to Python Script objects.</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="name">
    <english>Avoid using global statement</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="rationale">
    <english>Using global variables in short scripts can facilitate the rapid development of effective solutions. Python being originally a scripting language has the "global" keyword to declare in a given code block the scope of a variable as global. However use of global variables in OOP is strongly discouraged as it is contrary to encapsulation. Indeed, relying on global state can be a source of unexpected behavior because different elements in a code can freely modify it. Using global variables in Python can also have a negative impact on performance as code involving only local variables runs significantly faster.</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="remediation">
    <english>Create a static data member in the appropriate class to replace the global variable.</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="remediationSample">
    <english>class Status: 
    def __init__(self): 
        self.status = None
    
    def set_status(value) 
        status = value</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="sample">
    <english>status = 0 

def set_status(value): 
    global status 
    status = value</english>
  </metric>
  <metric id="1021068" type="quality-rule" originalName="Avoid using global statement" section="total">
    <english>Number of Python Modules and Functions</english>
  </metric>
  
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="description">
    <english>A violation is raised when a Superclass directly knows about its Subclasses. This happens when a Superclass directly calls a Subclass-method, uses a Subclass-attribute or refers to the name of the Subclass.</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="name">
    <english>Avoid Superclass knowing Subclass (Python)</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="rationale">
    <english>Referencing down the inheritance tree is against Object-Oriented coding practices. It is a way of having two-way inheritance between class and subclass. This is an indication of poor class design and use of class inheritance. Such practices increase the complexity of the application.</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="reference">
    <english>CISQ ASCRM-RLB-14 recommendation.</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="remediation">
    <english>Review the design of the Class hierarchy.</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="sample">
    <english>class A: 
    def add_value(self, x): 
        if instance(x, B): 
            pass 

class B(A): 
    pass</english>
  </metric>
  <metric id="1021070" type="quality-rule" originalName="Avoid Superclass knowing Subclass (Python)" section="total">
    <english>Number of Python Classes</english>
  </metric>
</root>