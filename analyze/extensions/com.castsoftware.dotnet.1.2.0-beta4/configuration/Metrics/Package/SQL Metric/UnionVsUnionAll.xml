<?xml version="1.0" encoding="utf-8"?>

<!-- ***********************************************************************
* Author : YLE@CAST
* Date : 2007.02.27
* Purpose : 
* Detects the use of UNION to set the metric "Prefer UNION ALL to UNION".
* Example : 
* If an object contains (only) the following query:
*   SELECT c1 FROM T1
*   UNION
*   SELECT c2 FROM T2
* ...the metric will be set to a non zero value.
* The other metric defined in this file is 'Use of UNION or UNION ALL'
* which is simply the number of 'UNION' in the source code being processed
*********************************************************************** -->

<METRIC PACKAGE_NAME="SQL Metric.UnionVsUnionAll">
	<ACTIVE>YES</ACTIVE>

	<!-- Used actions list -->
	<ACTION_LIST>
		<!-- match a pattern in a syntactic tree -->
		<ACTION NAME="MATCH IN TREE ELEMENT" >
			<INTERNAL_UID>8033D1FB-9FAB-4fcc-99A8-3ECD667C2889</INTERNAL_UID>
			<ACTIVE>YES</ACTIVE>
		</ACTION>
		<!-- match a regular expression -->
		<ACTION NAME="MATCH" >
			<INTERNAL_UID>1E981836-A530-4185-BA82-56E92E784545</INTERNAL_UID>
			<ACTIVE>YES</ACTIVE>
		</ACTION>
		<!-- save a computed value -->
		<ACTION NAME="PERSISTENCE" >
			<INTERNAL_UID>1AE3873E-AE59-4813-8914-18CF33125148</INTERNAL_UID>
			<ACTIVE>YES</ACTIVE>
		</ACTION>
	</ACTION_LIST>
	<!-- end of Used actions list -->

	<CATEGORY_LIST>
		<CATEGORY NAME="MATCH_SQL_UNION_NOT_ALL">
			<PROPERTY NAME="VALUE" TYPE="integer"/>
			<PROPERTY NAME="VALUE_EMBEDDED" TYPE="integer"/>

			<PROPERTY NAME="PATT_SQL_UNION_NOT_ALL" TYPE="pattern">
				<TREE>
					<OR>
						<!-- C/C++ -->
						<SIGNATURE>NODE_C_BODY</SIGNATURE>
						<!-- UDB/DSN -->
						<SIGNATURE>LIST_UDB_SQL_STATEMENT_LIST</SIGNATURE>
						<SIGNATURE>LIST_DSN_SQL_STATEMENT_LIST</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_VIEW</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_VIEW</SIGNATURE>
						<SIGNATURE>NODE_UDB_FUNC_RETURN</SIGNATURE>
						<SIGNATURE>NODE_DSN_FUNC_RETURN</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_TRIGGER_BEFORE</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_TRIGGER_AFTER</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_TRIGGER_BEFORE</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_TRIGGER_AFTER</SIGNATURE>
						<!-- PL-SQL -->
						<SIGNATURE>CLASS_PLSQL_function_body</SIGNATURE>
						<SIGNATURE>CLASS_PL_function_body</SIGNATURE> --
						<SIGNATURE>NODE_P23_TRIGGER</SIGNATURE>
						<SIGNATURE>NODE_PL_TRIGGER</SIGNATURE>  --
						<SIGNATURE>CLASS_PLSQL_procedure_body</SIGNATURE>
						<SIGNATURE>CLASS_PL_procedure_body</SIGNATURE>    --
						<SIGNATURE>NODE_P23_PACKAGE_BODY_1</SIGNATURE>
						<SIGNATURE>NODE_PL_PACKAGE_BODY_1</SIGNATURE> --
						<SIGNATURE>NODE_P23_PACKAGE_BODY_2</SIGNATURE>
						<SIGNATURE>NODE_PL_PACKAGE_BODY_2</SIGNATURE> --
						<SIGNATURE>NODE_P23_VIEW</SIGNATURE>
						<SIGNATURE>NODE_PL_VIEW</SIGNATURE> --
					</OR>
					<SUB_TREE_OR>
						<!-- UDB/DSN -->
						<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION"/>
						<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION"/>
						<!-- PL-SQL -->
						<SIGNATURE NAME="NODE_P23_UNION"/>
						<SIGNATURE NAME="NODE_PL_UNION"/> --
						<!-- T-SQL -->
						<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED"/>
						<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED"/>
					</SUB_TREE_OR>
				</TREE>
			</PROPERTY>
			<PROPERTY NAME="PATT_SQL_UNION_NOT_ALL_EMBEDDED" TYPE="pattern">
				<TREE>
					<OR>
						<SIGNATURE>CLASS_UDB_STMT_DT_ACCESS</SIGNATURE>
						<SIGNATURE>CLASS_DSN_STMT_DT_ACCESS</SIGNATURE>
						<SIGNATURE>NODE_P23_QUERY</SIGNATURE>
						<SIGNATURE>NODE_49X_SELECT</SIGNATURE>
					</OR>
					<TREE>
						<SUB_TREE_OR>
							<!-- UDB/DSN -->
							<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION"/>
							<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION"/>
							<!-- PL-SQL -->
							<SIGNATURE NAME="NODE_P23_UNION"/>
							<SIGNATURE NAME="NODE_PL_UNION"/> --
							<!-- T-SQL -->
							<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED"/>
							<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED"/>
							<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED"/>
							<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED"/>
							<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED"/>
							<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED"/>
						</SUB_TREE_OR>
					</TREE>
				</TREE>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH IN TREE ELEMENT">
				<MATCH>PATT_SQL_UNION_NOT_ALL</MATCH>
				<TOKEN>TOKEN_AND_TREE_ELEMENT.TOKEN_VALUE</TOKEN>
				<SIGNATURE>TOKEN_AND_TREE_ELEMENT.SIGNATURE_VALUE</SIGNATURE>
				<RESULT_COUNT>VALUE</RESULT_COUNT>
			</ADD_ACTION>
			<ADD_ACTION NAME="MATCH IN TREE ELEMENT">
				<MATCH>PATT_SQL_UNION_NOT_ALL_EMBEDDED</MATCH>
				<TOKEN>COBOL_EMBEDDED_SQL_TOKEN_AND_TREE_ELEMENT.TOKEN_VALUE</TOKEN>
				<SIGNATURE>COBOL_EMBEDDED_SQL_TOKEN_AND_TREE_ELEMENT.SIGNATURE_VALUE</SIGNATURE>
				<RESULT_COUNT>VALUE_EMBEDDED</RESULT_COUNT>
			</ADD_ACTION>

			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<NAME>Prefer UNION ALL to UNION</NAME>
			</ADD_ACTION>
			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE_EMBEDDED</SAVE>
				<NAME>Prefer UNION ALL to UNION</NAME>
			</ADD_ACTION>

		</CATEGORY>


		<!-- The dynamic SQL case: here we use a regex since the SQL 
			 code is considered as a string which is not parsed -->
		<CATEGORY NAME="MATCH_UNION_NOT_FOLLOWED_BY_ALL">
			<PROPERTY NAME="VALUE" type="integer" />
			<PROPERTY NAME="GREP_OR_IE" type="integer" />
			<PROPERTY NAME="REGEX_UNION_NOT_FOLLOWED_BY_ALL" type="regexp_pattern">
				<LANGUAGE>PLSQL-LANGUAGE</LANGUAGE>
				<SEARCH_IN_CODE>Yes</SEARCH_IN_CODE>
				<SEARCH_IN_COMMENT>No</SEARCH_IN_COMMENT>
				<SEARCH_IN_STRING>Yes</SEARCH_IN_STRING>
				<SEARCH_IN_EMBEDDEDSQL>No</SEARCH_IN_EMBEDDEDSQL>
				<SEARCH_CASE_SENSITIVE>No</SEARCH_CASE_SENSITIVE>
				<MATCH_WHOLE_WORD_ONLY>No</MATCH_WHOLE_WORD_ONLY>

				<REGEXP><![CDATA[([^[:word:]]|\\[rntfv])UNION([[:space:](]|\\[rntfv])+SELECT([^[:word:]]|\\[rntfv])]]></REGEXP>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH">
				<MATCH>REGEX_UNION_NOT_FOLLOWED_BY_ALL</MATCH>
				<SOURCE_CODE>GET_STRING_COMMENT_WITH_GREP.STRING_VALUE</SOURCE_CODE>
				<SOURCE_CODE>OBJECT.SQL_DYNAMIC_IE_SOURCECODE</SOURCE_CODE>
				<SOURCE_CODE>STRING_CONCATENATION.VALUE</SOURCE_CODE>
				<GREP_OR_IE_OUTPUT>GREP_OR_IE</GREP_OR_IE_OUTPUT>
				<VALUE_OUTPUT>VALUE</VALUE_OUTPUT>
			</ADD_ACTION>

			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<GREP_OR_IE>MATCH_UNION_NOT_FOLLOWED_BY_ALL.GREP_OR_IE</GREP_OR_IE>
				<NAME>Prefer UNION ALL to UNION</NAME>
			</ADD_ACTION>

		</CATEGORY>
		<!-- end of the dynamic SQL case -->

		<CATEGORY NAME="MATCH_SQL_UNION_OR_UNION_ALL">
			<PROPERTY NAME="VALUE" TYPE="integer"/>
			<PROPERTY NAME="VALUE_EMBEDDED" TYPE="integer"/>

			<PROPERTY NAME="PATT_SQL_UNION_OR_UNION_ALL" TYPE="pattern">
				<TREE>
					<OR>
						<!-- C/C++ -->
						<SIGNATURE>NODE_C_BODY</SIGNATURE>
						<!-- UDB/DSN -->
						<SIGNATURE>LIST_UDB_SQL_STATEMENT_LIST</SIGNATURE>
						<SIGNATURE>LIST_DSN_SQL_STATEMENT_LIST</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_VIEW</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_VIEW</SIGNATURE>
						<SIGNATURE>NODE_UDB_FUNC_RETURN</SIGNATURE>
						<SIGNATURE>NODE_DSN_FUNC_RETURN</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_TRIGGER_BEFORE</SIGNATURE>
						<SIGNATURE>NODE_UDB_CREATE_TRIGGER_AFTER</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_TRIGGER_BEFORE</SIGNATURE>
						<SIGNATURE>NODE_DSN_CREATE_TRIGGER_AFTER</SIGNATURE>
						<!-- PL-SQL -->
						<SIGNATURE>CLASS_PLSQL_function_body</SIGNATURE>
						<SIGNATURE>CLASS_PL_function_body</SIGNATURE> --

						<SIGNATURE>NODE_P23_TRIGGER</SIGNATURE>
						<SIGNATURE>NODE_PL_TRIGGER</SIGNATURE>  --
						<SIGNATURE>CLASS_PLSQL_procedure_body</SIGNATURE>
						<SIGNATURE>CLASS_PL_procedure_body</SIGNATURE>  --
						<SIGNATURE>NODE_P23_PACKAGE_BODY_1</SIGNATURE>
						<SIGNATURE>NODE_PL_PACKAGE_BODY_1</SIGNATURE> --
						<SIGNATURE>NODE_P23_PACKAGE_BODY_2</SIGNATURE>
						<SIGNATURE>NODE_PL_PACKAGE_BODY_2</SIGNATURE>
						<SIGNATURE>NODE_P23_VIEW</SIGNATURE>
						<SIGNATURE>NODE_PL_VIEW</SIGNATURE> --
					</OR>
					<SUB_TREE_OR>
						<!-- UDB/DSN -->
						<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION"/>
						<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION_ALL"/>
						<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION"/>
						<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION_ALL"/>
						<!-- PL-SQL -->
						<SIGNATURE NAME="NODE_P23_UNION"/>
						<SIGNATURE NAME="NODE_PL_UNION"/>     --
						<SIGNATURE NAME="NODE_P23_UNION_ALL"/>
						<SIGNATURE NAME="NODE_PL_UNION_ALL"/> --
						<!-- T-SQL -->
						<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED"/>
						<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED_ALL"/>
					</SUB_TREE_OR>
				</TREE>
			</PROPERTY>

			<PROPERTY NAME="PATT_SQL_UNION_OR_UNION_ALL_EMBEDDED" TYPE="pattern">
				<TREE>
					<OR>
						<SIGNATURE>CLASS_UDB_STMT_DT_ACCESS</SIGNATURE>
						<SIGNATURE>CLASS_DSN_STMT_DT_ACCESS</SIGNATURE>
						<SIGNATURE>NODE_P23_QUERY</SIGNATURE>
						<SIGNATURE>NODE_49X_SELECT</SIGNATURE>
					</OR>
					<SUB_TREE_OR>
						<!-- UDB/DSN -->
						<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION"/>
						<SIGNATURE NAME="NODE_UDB_FULLSELECT_UNION_ALL"/>
						<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION"/>
						<SIGNATURE NAME="NODE_DSN_FULLSELECT_UNION_ALL"/>
						<!-- PL-SQL -->
						<SIGNATURE NAME="NODE_P23_UNION"/>
						<SIGNATURE NAME="NODE_PL_UNION"/>     --
						<SIGNATURE NAME="NODE_P23_UNION_ALL"/>
						<SIGNATURE NAME="NODE_PL_UNION_ALL"/> --
						<!-- T-SQL -->
						<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY1_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY2_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED"/>
						<SIGNATURE NAME="NODE_M65_SUB_QUERY3_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED"/>
						<SIGNATURE NAME="NODE_S125_SUB_QUERY_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE_UNIONED_ALL"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED"/>
						<SIGNATURE NAME="NODE_49X_SELECT_TREE1_UNIONED_ALL"/>
					</SUB_TREE_OR>
				</TREE>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH IN TREE ELEMENT">
				<MATCH>PATT_SQL_UNION_OR_UNION_ALL</MATCH>
				<TOKEN>TOKEN_AND_TREE_ELEMENT.TOKEN_VALUE</TOKEN>
				<SIGNATURE>TOKEN_AND_TREE_ELEMENT.SIGNATURE_VALUE</SIGNATURE>
				<RESULT_COUNT>VALUE</RESULT_COUNT>
			</ADD_ACTION>
			<ADD_ACTION NAME="MATCH IN TREE ELEMENT">
				<MATCH>PATT_SQL_UNION_OR_UNION_ALL_EMBEDDED</MATCH>
				<TOKEN>COBOL_EMBEDDED_SQL_TOKEN_AND_TREE_ELEMENT.TOKEN_VALUE</TOKEN>
				<SIGNATURE>COBOL_EMBEDDED_SQL_TOKEN_AND_TREE_ELEMENT.SIGNATURE_VALUE</SIGNATURE>
				<RESULT_COUNT>VALUE_EMBEDDED</RESULT_COUNT>
			</ADD_ACTION>

			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<NAME>Use of UNION or UNION ALL</NAME>
			</ADD_ACTION>
			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE_EMBEDDED</SAVE>
				<NAME>Use of UNION or UNION ALL</NAME>
			</ADD_ACTION>

		</CATEGORY>


		<!-- The dynamic SQL case: here we use a regex since the SQL
			 code is considered as a string which is not parsed -->
		<CATEGORY NAME="MATCH_SQL_UNION_OR_UNION_ALL_GREP">
			<PROPERTY NAME="VALUE" type="integer" />
			<PROPERTY NAME="GREP_OR_IE" type="integer" />
			<PROPERTY NAME="REGEX_UNION_OR_UNION_ALL" type="regexp_pattern">
				<LANGUAGE>PLSQL-LANGUAGE</LANGUAGE>
				<SEARCH_IN_CODE>Yes</SEARCH_IN_CODE>
				<SEARCH_IN_COMMENT>No</SEARCH_IN_COMMENT>
				<SEARCH_IN_STRING>Yes</SEARCH_IN_STRING>
				<SEARCH_IN_EMBEDDEDSQL>No</SEARCH_IN_EMBEDDEDSQL>
				<SEARCH_CASE_SENSITIVE>No</SEARCH_CASE_SENSITIVE>
				<MATCH_WHOLE_WORD_ONLY>No</MATCH_WHOLE_WORD_ONLY>

				<REGEXP><![CDATA[([^[:word:]]|\\[rntfv])UNION(([[:space:]]|\\[rntfv])+ALL)?([[:space:](]|\\[rntfv])+SELECT([^[:word:]]|\\[rntfv])]]></REGEXP>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH">
				<MATCH>REGEX_UNION_OR_UNION_ALL</MATCH>
				<SOURCE_CODE>GET_STRING_COMMENT_WITH_GREP.STRING_VALUE</SOURCE_CODE>
				<SOURCE_CODE>OBJECT.SQL_DYNAMIC_IE_SOURCECODE</SOURCE_CODE>
				<SOURCE_CODE>STRING_CONCATENATION.VALUE</SOURCE_CODE>
				<GREP_OR_IE_OUTPUT>GREP_OR_IE</GREP_OR_IE_OUTPUT>
				<VALUE_OUTPUT>VALUE</VALUE_OUTPUT>
			</ADD_ACTION>

			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<GREP_OR_IE>MATCH_SQL_UNION_OR_UNION_ALL_GREP.GREP_OR_IE</GREP_OR_IE>
				<NAME>Use of UNION or UNION ALL</NAME>
			</ADD_ACTION>

		</CATEGORY>
		<!-- end of the dynamic SQL case -->

		<CATEGORY NAME="MATCH_SQL_UNION_OR_UNION_ALL_DB2_ZOS">
			<PROPERTY NAME="VALUE" type="integer" />
			<PROPERTY NAME="GREP_OR_IE" type="integer" />
			<PROPERTY NAME="REGEX_UNION_OR_UNION_ALL" type="regexp_pattern">
        <LANGUAGE>DB2-LANGUAGE</LANGUAGE>
        <LANGUAGE>DB2ZOS-LANGUAGE</LANGUAGE>
        <SEARCH_IN_CODE>Yes</SEARCH_IN_CODE>
				<SEARCH_IN_COMMENT>No</SEARCH_IN_COMMENT>
				<SEARCH_IN_STRING>No</SEARCH_IN_STRING>
				<SEARCH_IN_EMBEDDEDSQL>No</SEARCH_IN_EMBEDDEDSQL>
				<SEARCH_CASE_SENSITIVE>No</SEARCH_CASE_SENSITIVE>
				<!-- Beware, the search must be made 'whole word only' -->
				<MATCH_WHOLE_WORD_ONLY>Yes</MATCH_WHOLE_WORD_ONLY>
				<REGEXP><![CDATA[[[:Zs:]\t\r\n]UNION[[:Zs:]\t\r\n(]+SELECT[[:Zs:]\t\r\n]]]></REGEXP>
				<REGEXP><![CDATA[[[:Zs:]\t\r\n]UNION[[:Zs:]\t\r\n]+ALL[[:Zs:]\t\r\n(]+SELECT[[:Zs:]\t\r\n]]]></REGEXP>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH">
				<MATCH>REGEX_UNION_OR_UNION_ALL</MATCH>
				<CLASS>DB2_ZOS_CLASS.CLASS</CLASS>
				<SOURCE_CODE>OBJECT.SOURCECODE</SOURCE_CODE>
				<VALUE_OUTPUT>VALUE</VALUE_OUTPUT>
			</ADD_ACTION>


			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<NAME>Use of UNION or UNION ALL</NAME>
			</ADD_ACTION>

		</CATEGORY>

		<CATEGORY NAME="MATCH_REGEXP_UNION_OR_UNION_UA">
			<PROPERTY NAME="VALUE" type="integer" />
			<PROPERTY NAME="MATCH_REGEXP_UNION_OR_UNION" type="regexp_pattern">
				<SEARCH_IN_CODE>No</SEARCH_IN_CODE>
				<SEARCH_IN_COMMENT>No</SEARCH_IN_COMMENT>
				<SEARCH_IN_STRING>No</SEARCH_IN_STRING>
				<SEARCH_IN_EMBEDDEDSQL>Yes</SEARCH_IN_EMBEDDEDSQL>
				<SEARCH_CASE_SENSITIVE>No</SEARCH_CASE_SENSITIVE>
				<!-- note: the reg. exp. for U.A. volontarily doesn't recognize a '\' followed by 
				'r', or 'n', or 't' as an escape sequence for, respectively, CR, or LF, or TAB -->
				<REGEXP><![CDATA[[ \t\r\n]UNION[ \t\r\n(]+SELECT[ \t\r\n]]]></REGEXP>
				<REGEXP><![CDATA[[ \t\r\n]UNION[ \t\r\n]+ALL[ \t\r\n(]+SELECT[ \t\r\n]]]></REGEXP>
			</PROPERTY>

			<ADD_ACTION NAME="MATCH">
				<MATCH>MATCH_REGEXP_UNION_OR_UNION</MATCH>
				<SOURCE_CODE>OBJECT.SOURCECODE</SOURCE_CODE>
				<LANGUAGE_UA>OBJECT.LANGUAGE_UA</LANGUAGE_UA>
				<VALUE_OUTPUT>VALUE</VALUE_OUTPUT>
			</ADD_ACTION>

			<ADD_ACTION NAME="PERSISTENCE">
				<SAVE>VALUE</SAVE>
				<NAME>Use of UNION or UNION ALL</NAME>
			</ADD_ACTION>
		</CATEGORY>

	</CATEGORY_LIST>

</METRIC>
